<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Telegram Cleaner - Modern UI</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/react/18.2.0/umd/react.production.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/react-dom/18.2.0/umd/react-dom.production.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/babel-standalone/7.23.5/babel.min.js"></script>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link
        href="https://fonts.googleapis.com/css2?family=Outfit:wght@300;400;500;600;700;800&family=JetBrains+Mono:wght@400;600&display=swap"
        rel="stylesheet">
    <style>
        :root {
            --primary: #00aaff;
            --primary-light: #66ccff;
            --primary-dark: #0088dd;
            --secondary: #b87fff;
            --success: #4ade80;
            --danger: #ff8a8a;
            --warning: #fcd34d;
            --dark: #4a5568;
            --dark-light: #5a6a7f;
            --dark-lighter: #6b7b94;
            --text-primary: #ffffff;
            --text-secondary: #e2e8f0;
            --text-muted: #cbd5e0;
            --glass-bg: rgba(255, 255, 255, 0.15);
            --glass-border: rgba(255, 255, 255, 0.25);
            --shadow: rgba(0, 0, 0, 0.15);
        }

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Outfit', sans-serif;
            background: linear-gradient(135deg, #4a5568 0%, #5a6a7f 50%, #4a5568 100%);
            min-height: 100vh;
            color: var(--text-primary);
            padding: 20px;
            overflow-x: hidden;
            position: relative;
        }

        body::before {
            content: '';
            position: fixed;
            top: -50%;
            left: -50%;
            width: 200%;
            height: 200%;
            background:
                radial-gradient(circle at 20% 30%, rgba(0, 170, 255, 0.25) 0%, transparent 50%),
                radial-gradient(circle at 80% 70%, rgba(184, 127, 255, 0.25) 0%, transparent 50%),
                radial-gradient(circle at 50% 50%, rgba(74, 222, 128, 0.15) 0%, transparent 60%);
            animation: drift 30s infinite ease-in-out alternate;
            pointer-events: none;
            z-index: 0;
        }

        @keyframes drift {
            to {
                transform: translate(10%, 10%) rotate(5deg);
            }
        }

        .container {
            max-width: 1100px;
            margin: 0 auto;
            position: relative;
            z-index: 1;
        }

        .header {
            text-align: center;
            margin-bottom: 40px;
            animation: fadeInDown 0.8s ease-out;
        }

        @keyframes fadeInDown {
            from {
                opacity: 0;
                transform: translateY(-30px);
            }

            to {
                opacity: 1;
                transform: translateY(0);
            }
        }

        .header h1 {
            font-size: 56px;
            font-weight: 800;
            background: linear-gradient(135deg, var(--primary-light), var(--secondary));
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
            margin-bottom: 12px;
            letter-spacing: -1px;
        }

        .logo-container {
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 16px;
            margin-bottom: 8px;
        }

        .logo {
            width: 72px;
            height: 72px;
            filter: drop-shadow(0 4px 20px rgba(0, 170, 255, 0.4));
            animation: logoFloat 3s ease-in-out infinite;
        }

        @keyframes logoFloat {

            0%,
            100% {
                transform: translateY(0);
            }

            50% {
                transform: translateY(-6px);
            }
        }

        .logo-text {
            font-size: 48px;
            font-weight: 800;
            background: linear-gradient(135deg, var(--primary-light), var(--secondary));
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
            letter-spacing: -1px;
        }

        .header p {
            font-size: 18px;
            color: var(--text-secondary);
            font-weight: 400;
        }

        .glass-card {
            background: var(--glass-bg);
            backdrop-filter: blur(20px);
            -webkit-backdrop-filter: blur(20px);
            border: 1px solid var(--glass-border);
            border-radius: 24px;
            padding: 32px;
            box-shadow: 0 8px 32px var(--shadow);
            animation: fadeInUp 0.8s ease-out;
            animation-fill-mode: both;
        }

        @keyframes fadeInUp {
            from {
                opacity: 0;
                transform: translateY(30px);
            }

            to {
                opacity: 1;
                transform: translateY(0);
            }
        }

        .glass-card:nth-child(2) {
            animation-delay: 0.1s;
        }

        .glass-card:nth-child(3) {
            animation-delay: 0.2s;
        }

        .status-badge {
            display: inline-flex;
            align-items: center;
            gap: 8px;
            padding: 10px 20px;
            background: rgba(74, 222, 128, 0.15);
            border: 1px solid rgba(74, 222, 128, 0.4);
            border-radius: 50px;
            font-size: 14px;
            font-weight: 500;
            color: var(--success);
            margin-bottom: 24px;
        }

        .status-dot {
            width: 8px;
            height: 8px;
            background: var(--success);
            border-radius: 50%;
            animation: pulse 2s infinite;
        }

        @keyframes pulse {

            0%,
            100% {
                opacity: 1;
                box-shadow: 0 0 0 0 rgba(74, 222, 128, 0.7);
            }

            50% {
                opacity: 0.7;
                box-shadow: 0 0 0 10px rgba(74, 222, 128, 0);
            }
        }

        .stats-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 20px;
            margin-bottom: 32px;
        }

        .stat-card {
            background: var(--dark-lighter);
            border: 1px solid rgba(255, 255, 255, 0.1);
            border-radius: 16px;
            padding: 20px;
            transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
            position: relative;
            overflow: hidden;
        }

        .stat-card::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 3px;
            background: linear-gradient(90deg, var(--primary), var(--secondary));
            transform: scaleX(0);
            transition: transform 0.3s ease;
        }

        .stat-card:hover {
            transform: translateY(-5px);
            border-color: rgba(255, 255, 255, 0.15);
            box-shadow: 0 12px 24px rgba(0, 0, 0, 0.3);
        }

        .stat-card:hover::before {
            transform: scaleX(1);
        }

        .stat-number {
            font-size: 36px;
            font-weight: 800;
            background: linear-gradient(135deg, var(--primary-light), var(--primary));
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
            margin-bottom: 8px;
        }

        .stat-label {
            font-size: 13px;
            color: var(--text-muted);
            text-transform: uppercase;
            letter-spacing: 1px;
            font-weight: 600;
        }

        .selection-banner {
            background: linear-gradient(135deg, rgba(0, 170, 255, 0.2), rgba(184, 127, 255, 0.2));
            border: 1px solid var(--primary);
            border-radius: 16px;
            padding: 16px 24px;
            margin-bottom: 24px;
            display: flex;
            align-items: center;
            justify-content: space-between;
            animation: slideInRight 0.4s ease-out;
        }

        @keyframes slideInRight {
            from {
                opacity: 0;
                transform: translateX(50px);
            }

            to {
                opacity: 1;
                transform: translateX(0);
            }
        }

        .selection-info {
            display: flex;
            align-items: center;
            gap: 12px;
            font-weight: 600;
        }

        .action-buttons {
            display: flex;
            gap: 12px;
            margin-bottom: 16px;
            flex-wrap: wrap;
        }

        .btn {
            padding: 14px 28px;
            border: none;
            border-radius: 12px;
            font-size: 15px;
            font-weight: 600;
            font-family: 'Outfit', sans-serif;
            cursor: pointer;
            transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
            position: relative;
            overflow: hidden;
            text-transform: none;
        }

        .btn::before {
            content: '';
            position: absolute;
            top: 50%;
            left: 50%;
            width: 0;
            height: 0;
            border-radius: 50%;
            background: rgba(255, 255, 255, 0.1);
            transform: translate(-50%, -50%);
            transition: width 0.6s, height 0.6s;
        }

        .btn:hover::before {
            width: 300px;
            height: 300px;
        }

        .btn-primary {
            background: linear-gradient(135deg, var(--primary), var(--primary-dark));
            color: white;
            flex: 1;
        }

        .btn-primary:hover {
            transform: translateY(-2px);
            box-shadow: 0 8px 20px rgba(16, 185, 129, 0.4);
        }

        .btn-secondary {
            background: var(--dark-lighter);
            color: var(--text-primary);
            border: 1px solid rgba(255, 255, 255, 0.2);
            flex: 1;
        }

        .btn-secondary:hover {
            background: var(--dark-light);
            border-color: rgba(255, 255, 255, 0.3);
            transform: translateY(-2px);
        }

        .btn-danger {
            background: linear-gradient(135deg, var(--danger), #e85555);
            color: white;
            width: 100%;
        }

        .btn-danger:hover {
            transform: translateY(-2px);
            box-shadow: 0 8px 20px rgba(248, 113, 113, 0.4);
        }

        .btn:focus-visible {
            outline: 2px solid var(--primary-light);
            outline-offset: 2px;
        }

        .btn:disabled {
            opacity: 0.4;
            cursor: not-allowed;
            transform: none !important;
        }

        .chat-list {
            max-height: 600px;
            overflow-y: auto;
            overflow-x: hidden;
            padding-right: 8px;
        }

        .chat-list::-webkit-scrollbar {
            width: 6px;
        }

        .chat-list::-webkit-scrollbar-track {
            background: transparent;
        }

        .chat-list::-webkit-scrollbar-thumb {
            background: rgba(255, 255, 255, 0.1);
            border-radius: 10px;
        }

        .chat-list::-webkit-scrollbar-thumb:hover {
            background: rgba(255, 255, 255, 0.2);
        }

        .chat-item {
            margin-bottom: 12px;
            border-radius: 16px;
            overflow: hidden;
            background: var(--dark-lighter);
            border: 1px solid transparent;
            transition: all 0.3s ease;
        }

        .chat-item:hover {
            border-color: rgba(255, 255, 255, 0.1);
            transform: translateX(4px);
        }

        .chat-header {
            padding: 20px;
            display: flex;
            align-items: center;
            gap: 16px;
            cursor: pointer;
            position: relative;
        }

        .chat-header.expanded {
            background: linear-gradient(135deg, rgba(0, 170, 255, 0.08), rgba(184, 127, 255, 0.08));
            border-bottom: 1px solid rgba(255, 255, 255, 0.1);
        }

        .checkbox-wrapper {
            position: relative;
            display: inline-block;
        }

        .checkbox {
            appearance: none;
            width: 22px;
            height: 22px;
            border: 2px solid rgba(255, 255, 255, 0.4);
            border-radius: 6px;
            cursor: pointer;
            position: relative;
            transition: all 0.3s ease;
            background: rgba(255, 255, 255, 0.1);
        }

        .checkbox:checked {
            background: linear-gradient(135deg, var(--primary), var(--secondary));
            border-color: var(--primary);
        }

        .checkbox:checked::after {
            content: 'âœ“';
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            color: white;
            font-size: 14px;
            font-weight: bold;
        }

        .checkbox:focus-visible {
            outline: 2px solid var(--primary-light);
            outline-offset: 2px;
        }

        .avatar {
            width: 56px;
            height: 56px;
            border-radius: 16px;
            background: linear-gradient(135deg, var(--primary), var(--secondary));
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 24px;
            font-weight: 700;
            color: white;
            flex-shrink: 0;
            box-shadow: 0 4px 12px rgba(0, 170, 255, 0.35);
        }

        .chat-info {
            flex: 1;
            min-width: 0;
            border-radius: 8px;
            padding: 4px;
            margin: -4px;
        }

        .chat-info:focus-visible {
            outline: 2px solid var(--primary-light);
            outline-offset: 2px;
        }

        .chat-name {
            font-size: 18px;
            font-weight: 600;
            color: var(--text-primary);
            margin-bottom: 6px;
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .chat-preview {
            font-size: 14px;
            color: var(--text-secondary);
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
        }

        .chat-meta {
            text-align: right;
            display: flex;
            flex-direction: column;
            align-items: flex-end;
            gap: 6px;
        }

        .message-count {
            font-family: 'JetBrains Mono', monospace;
            font-size: 13px;
            font-weight: 600;
            color: var(--primary);
            padding: 4px 12px;
            background: rgba(0, 170, 255, 0.15);
            border-radius: 8px;
        }

        .chat-time {
            font-size: 12px;
            color: var(--text-muted);
        }

        .expand-icon {
            font-size: 12px;
            color: var(--text-muted);
            transition: transform 0.3s ease;
        }

        .expand-icon.expanded {
            transform: rotate(180deg);
        }

        .messages-container {
            padding: 20px;
            background: rgba(0, 0, 0, 0.15);
            animation: expandDown 0.3s ease-out;
        }

        @keyframes expandDown {
            from {
                opacity: 0;
                transform: translateY(-10px);
            }

            to {
                opacity: 1;
                transform: translateY(0);
            }
        }

        .message-controls {
            display: flex;
            gap: 12px;
            margin-bottom: 16px;
        }

        .message-controls .btn {
            padding: 10px 20px;
            font-size: 14px;
        }

        .messages-list {
            max-height: 400px;
            overflow-y: auto;
            padding-right: 8px;
        }

        .messages-list::-webkit-scrollbar {
            width: 4px;
        }

        .messages-list::-webkit-scrollbar-track {
            background: transparent;
        }

        .messages-list::-webkit-scrollbar-thumb {
            background: rgba(255, 255, 255, 0.1);
            border-radius: 10px;
        }

        .message-item {
            padding: 16px;
            background: var(--dark-light);
            border-radius: 12px;
            margin-bottom: 10px;
            display: flex;
            gap: 12px;
            align-items: flex-start;
            border: 1px solid transparent;
            transition: all 0.3s ease;
        }

        .message-item:hover {
            border-color: rgba(255, 255, 255, 0.1);
            transform: translateX(4px);
        }

        .message-item.selected {
            background: linear-gradient(135deg, rgba(0, 170, 255, 0.18), rgba(184, 127, 255, 0.18));
            border-color: var(--primary);
        }

        .message-checkbox {
            margin-top: 2px;
        }

        .message-content {
            flex: 1;
        }

        .message-text {
            color: var(--text-primary);
            font-size: 15px;
            line-height: 1.6;
            margin-bottom: 8px;
        }

        .message-meta {
            display: flex;
            align-items: center;
            gap: 10px;
            font-size: 12px;
            color: var(--text-muted);
        }

        .message-type {
            display: inline-flex;
            align-items: center;
            gap: 4px;
            padding: 4px 10px;
            background: rgba(255, 255, 255, 0.08);
            border-radius: 6px;
            font-size: 11px;
            font-weight: 600;
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }

        .message-type.photo {
            background: rgba(52, 211, 153, 0.2);
            color: var(--success);
        }

        .message-type.video {
            background: rgba(0, 153, 230, 0.2);
            color: var(--primary-light);
        }

        .message-type.file {
            background: rgba(251, 191, 36, 0.2);
            color: var(--warning);
        }

        .message-sender {
            color: var(--primary-light);
            font-weight: 600;
        }

        @media (max-width: 768px) {
            .header h1 {
                font-size: 36px;
            }

            .stats-grid {
                grid-template-columns: 1fr;
            }

            .action-buttons {
                flex-direction: column;
            }

            .glass-card {
                padding: 20px;
            }
        }

        .badge {
            font-size: 18px;
            filter: drop-shadow(0 2px 4px rgba(0, 0, 0, 0.3));
        }

        .loading-spinner {
            display: inline-block;
            width: 16px;
            height: 16px;
            border: 2px solid rgba(255, 255, 255, 0.3);
            border-top-color: white;
            border-radius: 50%;
            animation: spin 0.8s linear infinite;
        }

        @keyframes spin {
            to {
                transform: rotate(360deg);
            }
        }

        .btn-refresh {
            background: linear-gradient(135deg, var(--secondary), #9333ea);
            color: white;
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 8px;
            min-width: 140px;
        }

        .btn-refresh:hover {
            transform: translateY(-2px);
            box-shadow: 0 8px 20px rgba(184, 127, 255, 0.4);
        }

        .btn-refresh .refresh-icon {
            display: inline-block;
            transition: transform 0.3s ease;
        }

        .btn-refresh.refreshing .refresh-icon {
            animation: spin 1s linear infinite;
        }

        .refresh-info {
            display: flex;
            align-items: center;
            justify-content: space-between;
            margin-bottom: 16px;
            padding: 12px 16px;
            background: var(--dark-lighter);
            border-radius: 12px;
            font-size: 13px;
            color: var(--text-muted);
        }

        .refresh-info span {
            display: flex;
            align-items: center;
            gap: 6px;
        }

        /* Login Screen Styles */
        .login-container {
            max-width: 420px;
            margin: 60px auto;
        }

        .login-card {
            background: var(--glass-bg);
            backdrop-filter: blur(20px);
            border: 1px solid var(--glass-border);
            border-radius: 24px;
            padding: 40px;
            text-align: center;
        }

        .login-logo {
            width: 80px;
            height: 80px;
            margin: 0 auto 24px;
        }

        .login-title {
            font-size: 28px;
            font-weight: 700;
            margin-bottom: 8px;
            background: linear-gradient(135deg, var(--primary-light), var(--secondary));
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
        }

        .login-subtitle {
            color: var(--text-secondary);
            margin-bottom: 32px;
            font-size: 15px;
        }

        .input-group {
            margin-bottom: 20px;
            text-align: left;
        }

        .input-label {
            display: block;
            font-size: 13px;
            font-weight: 600;
            color: var(--text-secondary);
            margin-bottom: 8px;
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }

        .input-field {
            width: 100%;
            padding: 16px 20px;
            background: var(--dark-lighter);
            border: 2px solid transparent;
            border-radius: 12px;
            color: var(--text-primary);
            font-size: 16px;
            font-family: 'Outfit', sans-serif;
            transition: all 0.3s ease;
            outline: none;
        }

        .input-field:focus {
            border-color: var(--primary);
            box-shadow: 0 0 0 4px rgba(0, 170, 255, 0.15);
        }

        .input-field::placeholder {
            color: var(--text-muted);
        }

        .login-btn {
            width: 100%;
            padding: 16px;
            margin-top: 12px;
        }

        .login-error {
            background: rgba(255, 138, 138, 0.15);
            border: 1px solid var(--danger);
            border-radius: 12px;
            padding: 12px 16px;
            margin-bottom: 20px;
            color: var(--danger);
            font-size: 14px;
        }

        .login-info {
            background: rgba(0, 170, 255, 0.1);
            border: 1px solid rgba(0, 170, 255, 0.3);
            border-radius: 12px;
            padding: 12px 16px;
            margin-bottom: 20px;
            color: var(--primary-light);
            font-size: 14px;
        }

        .step-indicator {
            display: flex;
            justify-content: center;
            gap: 8px;
            margin-bottom: 24px;
        }

        .step-dot {
            width: 10px;
            height: 10px;
            border-radius: 50%;
            background: var(--dark-lighter);
            transition: all 0.3s ease;
        }

        .step-dot.active {
            background: var(--primary);
            box-shadow: 0 0 10px rgba(0, 170, 255, 0.5);
        }

        .step-dot.completed {
            background: var(--success);
        }

        /* Progress bar for deletion */
        .deletion-progress {
            background: var(--dark-lighter);
            border-radius: 12px;
            padding: 20px;
            margin-bottom: 20px;
        }

        .progress-bar-container {
            background: var(--dark);
            border-radius: 8px;
            height: 12px;
            overflow: hidden;
            margin: 12px 0;
        }

        .progress-bar {
            height: 100%;
            background: linear-gradient(90deg, var(--primary), var(--secondary));
            border-radius: 8px;
            transition: width 0.3s ease;
        }

        .progress-stats {
            display: flex;
            justify-content: space-between;
            font-size: 13px;
            color: var(--text-muted);
        }

        .logout-btn {
            background: transparent;
            border: 1px solid var(--danger);
            color: var(--danger);
            padding: 8px 16px;
            border-radius: 8px;
            font-size: 13px;
            cursor: pointer;
            transition: all 0.3s ease;
        }

        .logout-btn:hover {
            background: var(--danger);
            color: white;
        }

        .api-setup {
            margin-top: 24px;
            padding-top: 24px;
            border-top: 1px solid var(--glass-border);
        }

        .api-setup-title {
            font-size: 14px;
            color: var(--text-muted);
            margin-bottom: 16px;
        }

        .api-link {
            color: var(--primary-light);
            text-decoration: none;
        }

        .api-link:hover {
            text-decoration: underline;
        }

        .language-selector {
            position: absolute;
            top: 20px;
            right: 20px;
            display: flex;
            gap: 8px;
            z-index: 100;
            background: rgba(0, 0, 0, 0.2);
            padding: 4px;
            border-radius: 12px;
            backdrop-filter: blur(10px);
        }

        .lang-btn {
            background: transparent;
            border: none;
            color: var(--text-muted);
            padding: 6px 12px;
            border-radius: 8px;
            cursor: pointer;
            font-weight: 600;
            font-family: 'Outfit', sans-serif;
            transition: all 0.3s ease;
        }

        .lang-btn:hover {
            color: var(--text-primary);
            background: rgba(255, 255, 255, 0.05);
        }

        .lang-btn.active {
            background: var(--primary);
            color: white;
            box-shadow: 0 2px 8px rgba(0, 170, 255, 0.3);
        }

        .instructions-modal {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(0, 0, 0, 0.8);
            display: flex;
            align-items: center;
            justify-content: center;
            z-index: 10000;
            padding: 20px;
            backdrop-filter: blur(10px);
        }

        .instructions-content {
            background: linear-gradient(135deg, #1a1d29 0%, #252836 100%);
            border: 1px solid var(--glass-border);
            border-radius: 20px;
            padding: 30px;
            max-width: 700px;
            max-height: 80vh;
            overflow-y: auto;
            box-shadow: 0 20px 60px rgba(0, 0, 0, 0.5);
            position: relative;
        }

        .instructions-content h2 {
            margin: 0 0 20px 0;
            font-size: 28px;
            font-weight: 700;
            color: var(--text-primary);
            display: flex;
            align-items: center;
            justify-content: space-between;
        }

        .instructions-close {
            background: rgba(255, 255, 255, 0.1);
            border: none;
            color: var(--text-primary);
            font-size: 24px;
            width: 32px;
            height: 32px;
            border-radius: 50%;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: all 0.3s ease;
        }

        .instructions-close:hover {
            background: rgba(255, 255, 255, 0.2);
            transform: rotate(90deg);
        }

        .instructions-text {
            color: var(--text-secondary);
            line-height: 1.8;
            white-space: pre-line;
            font-size: 15px;
        }

        .instructions-text a {
            color: var(--primary);
            text-decoration: none;
            font-weight: 600;
        }

        .instructions-text a:hover {
            text-decoration: underline;
        }

        .instructions-link {
            color: #10b981;
            text-decoration: none;
            font-weight: 600;
            margin-left: 8px;
            cursor: pointer;
            transition: all 0.3s ease;
        }

        .instructions-link:hover {
            text-decoration: underline;
            color: #34d399;
        }
    </style>
</head>

<body>
    <div id="root"></div>

    <script type="text/babel">
        const { useState, useEffect, createContext, useContext } = React;

        // ==================== LOCALIZATION ====================
        const translations = {
            en: {
                appTitle: "Telegram Cleaner",
                subtitle: "Clean up your messages with style",
                loginTitle: "Telegram Cleaner",
                loginSubtitle: {
                    api: "Enter your Telegram API credentials",
                    phone: "Enter your phone number",
                    code: "Enter the verification code",
                    "2fa": "Enter your 2FA password"
                },
                labels: {
                    apiId: "API ID",
                    apiHash: "API Hash",
                    phone: "Phone Number",
                    code: "Verification Code",
                    password: "2FA Password"
                },
                buttons: {
                    continue: "Continue",
                    sendCode: "Send Code",
                    verify: "Verify",
                    submit: "Submit",
                    logout: "Logout",
                    selectAll: "âœ“ Select All Chats",
                    deselectAll: "âœ— Deselect All",
                    refresh: "Refresh",
                    refreshing: "Refreshing...",
                    delete: "ðŸ—‘ï¸ Delete {count} Message{s}",
                    deleting: "Deleting..."
                },
                stats: {
                    totalChats: "Total Chats",
                    chatsSelected: "Chats Selected",
                    messagesSelected: "Messages Selected"
                },
                status: {
                    connectedAs: "Connected as",
                    readyToDelete: "{count} message{s} ready to delete",
                    messagesLoaded: "{count} messages loaded from {chats} chats",
                    lastRefresh: "Last refresh: {time}",
                    notRefreshed: "Not refreshed yet",
                    deletingMessages: "ðŸ—‘ï¸ Deleting messages...",
                    deletedProgress: "{current} / {total} deleted",
                    downloadingMessages: "ðŸ“¥ Downloading messages from: {chatName}",
                    downloadProgress: "{current} / {total} downloaded",
                    loading: "Loading...",
                    floodWaitLong: "FLOOD_WAIT error: {seconds} seconds. This is too long. Please wait and try again later.",
                    floodWaitShort: "FLOOD_WAIT error: {seconds} seconds. Aborting deletion. Please try again later."
                },
                search: "Search chats or messages...",
                searchResults: {
                    noMessages: "No messages found",
                    tryDifferent: "Try a different search term",
                    messagesFound: "message(s) found",
                    searchFor: "Search results for:",
                    chats: "chat(s)",
                    messages: "message(s)",
                    clear: "Clear",
                    searchingLoaded: "Searching in {loaded} of {total} chats with loaded messages",
                    expandToLoad: "Expand chats below to load their messages and search through them"
                },
                chat: {
                    my: "My:",
                    u: "U", // User avatar fallback
                    group: "Group chat",
                    private: "Private chat",
                    photo: "ðŸ“· Photo",
                    video: "ðŸŽ¥ Video",
                    file: "ðŸ“Ž File",
                    noMessages: "No messages from you in this chat",
                    selectAllMessages: "âœ“ Select All ({count})",
                    deselectAllMessages: "âœ— Deselect All",
                    syncing: "Syncing history... ({count} loaded)",
                    endOfHistory: "âœ“ End of message history ({count} total)",
                    deletePrompt: "Delete {count} selected message(s)?\n\nThis will delete for everyone. This cannot be undone!"
                },
                apiSetup: "Get credentials from",
                instructions: {
                    title: "Instructions",
                    content: `To log in, you need to obtain your API ID and API hash from Telegram.
It would take a long time to explain what these are, but you can't do without them.
To do this, go to https://my.telegram.org/auth?to=apps

Enter your phone number, and Telegram will send you a code. The code will be sent to you in the Telegram app as a new chat.
Next, fill in the fields:

App title: - write anything you want, such as TelegramCleanerWorkingVersion
Short name: - write anything you want, such as TelegramCleaner
Check the box on the last line, Other (specify in description)
Click Create application

Telegram will give you a bunch of incomprehensible lines, letters, and numbers.
You need to remember and save: API ID - these are numbers (for the Telegram server, this is like your username)
You need to remember and save: API hash - (for the Telegram server, this is like your password)

âš ï¸ Warning: NEVER show anyone your API ID and API hash, as they provide direct access to your account.

To log into my app, you will need your API ID and API hash + phone number + password, if you have a cloud password + the code that TG will send you (not via SMS, but in the TG app on your phone in the form of a chat). FIRST ENTER THE CODE FROM THE CLOUD PASSWORD, WAIT FOR THE CODE FROM TG, AND THEN ENTER IT. After the first login, the app will remember this and you will not need to re-enter it in the future, everything will already be filled in, unless you click "log out of account", for example, if you want to use the app for another account.

â„¹ï¸ IMPORTANT: The application uses and stores all data only on your device.
The program will download a list of your messages in selected chats.
You can check the box next to a chat and click "Delete ALL messages" to delete ALL messages in that chat.
Or you can select individual messages and click "Delete SELECTED messages" to delete the messages you have selected in this chat.
IMPORTANT: The program only deletes messages in chats that you are a member of. If you have left the chat, it will not show that chat in the list. To delete messages, you must first join the chat, run the program, delete messages, and then leave the chat.
The program shows only chats/groups, including closed ones. It does not show personal chats because they can be deleted through the Telegram app.`
                }
            },
            ru: {
                appTitle: "Telegram Cleaner",
                subtitle: "ÐžÑ‡Ð¸ÑÑ‚Ð¸Ñ‚Ðµ ÑÐ²Ð¾Ð¸ ÑÐ¾Ð¾Ð±Ñ‰ÐµÐ½Ð¸Ñ ÑÑ‚Ð¸Ð»ÑŒÐ½Ð¾",
                loginTitle: "Telegram Cleaner",
                loginSubtitle: {
                    api: "Ð’Ð²ÐµÐ´Ð¸Ñ‚Ðµ API Ð´Ð°Ð½Ð½Ñ‹Ðµ Telegram",
                    phone: "Ð’Ð²ÐµÐ´Ð¸Ñ‚Ðµ Ð²Ð°Ñˆ Ð½Ð¾Ð¼ÐµÑ€ Ñ‚ÐµÐ»ÐµÑ„Ð¾Ð½Ð°",
                    code: "Ð’Ð²ÐµÐ´Ð¸Ñ‚Ðµ ÐºÐ¾Ð´ Ð¿Ð¾Ð´Ñ‚Ð²ÐµÑ€Ð¶Ð´ÐµÐ½Ð¸Ñ",
                    "2fa": "Ð’Ð²ÐµÐ´Ð¸Ñ‚Ðµ Ð¿Ð°Ñ€Ð¾Ð»ÑŒ 2FA"
                },
                labels: {
                    apiId: "API ID",
                    apiHash: "API Hash",
                    phone: "ÐÐ¾Ð¼ÐµÑ€ Ñ‚ÐµÐ»ÐµÑ„Ð¾Ð½Ð°",
                    code: "ÐšÐ¾Ð´ Ð¿Ð¾Ð´Ñ‚Ð²ÐµÑ€Ð¶Ð´ÐµÐ½Ð¸Ñ",
                    password: "ÐŸÐ°Ñ€Ð¾Ð»ÑŒ 2FA"
                },
                buttons: {
                    continue: "ÐŸÑ€Ð¾Ð´Ð¾Ð»Ð¶Ð¸Ñ‚ÑŒ",
                    sendCode: "ÐžÑ‚Ð¿Ñ€Ð°Ð²Ð¸Ñ‚ÑŒ ÐºÐ¾Ð´",
                    verify: "ÐŸÐ¾Ð´Ñ‚Ð²ÐµÑ€Ð´Ð¸Ñ‚ÑŒ",
                    submit: "Ð’Ð¾Ð¹Ñ‚Ð¸",
                    logout: "Ð’Ñ‹Ð¹Ñ‚Ð¸",
                    selectAll: "âœ“ Ð’Ñ‹Ð±Ñ€Ð°Ñ‚ÑŒ Ð²ÑÐµ Ñ‡Ð°Ñ‚Ñ‹",
                    deselectAll: "âœ— Ð¡Ð½ÑÑ‚ÑŒ Ð²Ñ‹Ð±Ð¾Ñ€",
                    refresh: "ÐžÐ±Ð½Ð¾Ð²Ð¸Ñ‚ÑŒ",
                    refreshing: "ÐžÐ±Ð½Ð¾Ð²Ð»ÐµÐ½Ð¸Ðµ...",
                    delete: "ðŸ—‘ï¸ Ð£Ð´Ð°Ð»Ð¸Ñ‚ÑŒ {count} ÑÐ¾Ð¾Ð±Ñ‰ÐµÐ½Ð¸Ð¹",
                    deleting: "Ð£Ð´Ð°Ð»ÐµÐ½Ð¸Ðµ..."
                },
                stats: {
                    totalChats: "Ð’ÑÐµÐ³Ð¾ Ñ‡Ð°Ñ‚Ð¾Ð²",
                    chatsSelected: "Ð’Ñ‹Ð±Ñ€Ð°Ð½Ð¾ Ñ‡Ð°Ñ‚Ð¾Ð²",
                    messagesSelected: "Ð’Ñ‹Ð±Ñ€Ð°Ð½Ð¾ ÑÐ¾Ð¾Ð±Ñ‰ÐµÐ½Ð¸Ð¹"
                },
                status: {
                    connectedAs: "Ð’Ñ…Ð¾Ð´ Ð²Ñ‹Ð¿Ð¾Ð»Ð½ÐµÐ½ ÐºÐ°Ðº",
                    readyToDelete: "{count} ÑÐ¾Ð¾Ð±Ñ‰ÐµÐ½Ð¸Ð¹ Ð³Ð¾Ñ‚Ð¾Ð²Ð¾ Ðº ÑƒÐ´Ð°Ð»ÐµÐ½Ð¸ÑŽ",
                    messagesLoaded: "Ð—Ð°Ð³Ñ€ÑƒÐ¶ÐµÐ½Ð¾ {count} ÑÐ¾Ð¾Ð±Ñ‰ÐµÐ½Ð¸Ð¹ Ð¸Ð· {chats} Ñ‡Ð°Ñ‚Ð¾Ð²",
                    lastRefresh: "ÐŸÐ¾ÑÐ»ÐµÐ´Ð½ÐµÐµ Ð¾Ð±Ð½Ð¾Ð²Ð»ÐµÐ½Ð¸Ðµ: {time}",
                    notRefreshed: "ÐÐµ Ð¾Ð±Ð½Ð¾Ð²Ð»ÑÐ»Ð¾ÑÑŒ",
                    deletingMessages: "ðŸ—‘ï¸ Ð£Ð´Ð°Ð»ÐµÐ½Ð¸Ðµ ÑÐ¾Ð¾Ð±Ñ‰ÐµÐ½Ð¸Ð¹...",
                    deletedProgress: "Ð£Ð´Ð°Ð»ÐµÐ½Ð¾ {current} Ð¸Ð· {total}",
                    downloadingMessages: "ðŸ“¥ Ð—Ð°Ð³Ñ€ÑƒÐ·ÐºÐ° ÑÐ¾Ð¾Ð±Ñ‰ÐµÐ½Ð¸Ð¹ Ð¸Ð·: {chatName}",
                    downloadProgress: "Ð—Ð°Ð³Ñ€ÑƒÐ¶ÐµÐ½Ð¾ {current} Ð¸Ð· {total}",
                    loading: "Ð—Ð°Ð³Ñ€ÑƒÐ·ÐºÐ°...",
                    floodWaitLong: "ÐžÑˆÐ¸Ð±ÐºÐ° FLOOD_WAIT: {seconds} ÑÐµÐºÑƒÐ½Ð´. Ð­Ñ‚Ð¾ ÑÐ»Ð¸ÑˆÐºÐ¾Ð¼ Ð´Ð¾Ð»Ð³Ð¾. ÐŸÐ¾Ð¶Ð°Ð»ÑƒÐ¹ÑÑ‚Ð°, Ð¿Ð¾Ð´Ð¾Ð¶Ð´Ð¸Ñ‚Ðµ Ð¸ Ð¿Ð¾Ð¿Ñ€Ð¾Ð±ÑƒÐ¹Ñ‚Ðµ Ð¿Ð¾Ð·Ð¶Ðµ.",
                    floodWaitShort: "ÐžÑˆÐ¸Ð±ÐºÐ° FLOOD_WAIT: {seconds} ÑÐµÐºÑƒÐ½Ð´. Ð£Ð´Ð°Ð»ÐµÐ½Ð¸Ðµ Ð¿Ñ€ÐµÑ€Ð²Ð°Ð½Ð¾. ÐŸÐ¾Ð¶Ð°Ð»ÑƒÐ¹ÑÑ‚Ð°, Ð¿Ð¾Ð¿Ñ€Ð¾Ð±ÑƒÐ¹Ñ‚Ðµ Ð¿Ð¾Ð·Ð¶Ðµ."
                },
                search: "ÐŸÐ¾Ð¸ÑÐº Ñ‡Ð°Ñ‚Ð¾Ð² Ð¸Ð»Ð¸ ÑÐ¾Ð¾Ð±Ñ‰ÐµÐ½Ð¸Ð¹...",
                searchResults: {
                    noMessages: "Ð¡Ð¾Ð¾Ð±Ñ‰ÐµÐ½Ð¸Ñ Ð½Ðµ Ð½Ð°Ð¹Ð´ÐµÐ½Ñ‹",
                    tryDifferent: "ÐŸÐ¾Ð¿Ñ€Ð¾Ð±ÑƒÐ¹Ñ‚Ðµ Ð´Ñ€ÑƒÐ³Ð¾Ð¹ Ð·Ð°Ð¿Ñ€Ð¾Ñ",
                    messagesFound: "ÑÐ¾Ð¾Ð±Ñ‰ÐµÐ½Ð¸Ð¹ Ð½Ð°Ð¹Ð´ÐµÐ½Ð¾",
                    searchFor: "Ð ÐµÐ·ÑƒÐ»ÑŒÑ‚Ð°Ñ‚Ñ‹ Ð¿Ð¾Ð¸ÑÐºÐ°:",
                    chats: "Ñ‡Ð°Ñ‚Ð¾Ð²",
                    messages: "ÑÐ¾Ð¾Ð±Ñ‰ÐµÐ½Ð¸Ð¹",
                    clear: "ÐžÑ‡Ð¸ÑÑ‚Ð¸Ñ‚ÑŒ",
                    searchingLoaded: "ÐŸÐ¾Ð¸ÑÐº Ð² {loaded} Ð¸Ð· {total} Ñ‡Ð°Ñ‚Ð¾Ð² Ñ Ð·Ð°Ð³Ñ€ÑƒÐ¶ÐµÐ½Ð½Ñ‹Ð¼Ð¸ ÑÐ¾Ð¾Ð±Ñ‰ÐµÐ½Ð¸ÑÐ¼Ð¸",
                    expandToLoad: "Ð Ð°Ð·Ð²ÐµÑ€Ð½Ð¸Ñ‚Ðµ Ñ‡Ð°Ñ‚Ñ‹ Ð½Ð¸Ð¶Ðµ, Ñ‡Ñ‚Ð¾Ð±Ñ‹ Ð·Ð°Ð³Ñ€ÑƒÐ·Ð¸Ñ‚ÑŒ Ð¸Ñ… ÑÐ¾Ð¾Ð±Ñ‰ÐµÐ½Ð¸Ñ Ð¸ Ð²Ñ‹Ð¿Ð¾Ð»Ð½Ð¸Ñ‚ÑŒ Ð¿Ð¾Ð¸ÑÐº"
                },
                chat: {
                    my: "ÐœÐ¾Ð¸:",
                    u: "ÐŸ", // ÐŸÐ¾Ð»ÑŒÐ·Ð¾Ð²Ð°Ñ‚ÐµÐ»ÑŒ
                    group: "Ð“Ñ€ÑƒÐ¿Ð¿Ð¾Ð²Ð¾Ð¹ Ñ‡Ð°Ñ‚",
                    private: "Ð›Ð¸Ñ‡Ð½Ñ‹Ð¹ Ñ‡Ð°Ñ‚",
                    photo: "ðŸ“· Ð¤Ð¾Ñ‚Ð¾",
                    video: "ðŸŽ¥ Ð’Ð¸Ð´ÐµÐ¾",
                    file: "ðŸ“Ž Ð¤Ð°Ð¹Ð»",
                    noMessages: "ÐÐµÑ‚ Ð²Ð°ÑˆÐ¸Ñ… ÑÐ¾Ð¾Ð±Ñ‰ÐµÐ½Ð¸Ð¹ Ð² ÑÑ‚Ð¾Ð¼ Ñ‡Ð°Ñ‚Ðµ",
                    selectAllMessages: "âœ“ Ð’Ñ‹Ð±Ñ€Ð°Ñ‚ÑŒ Ð²ÑÐµ ({count})",
                    deselectAllMessages: "âœ— Ð¡Ð½ÑÑ‚ÑŒ Ð²Ñ‹Ð±Ð¾Ñ€",
                    syncing: "Ð¡Ð¸Ð½Ñ…Ñ€Ð¾Ð½Ð¸Ð·Ð°Ñ†Ð¸Ñ... ({count} Ð·Ð°Ð³Ñ€ÑƒÐ¶ÐµÐ½Ð¾)",
                    endOfHistory: "âœ“ Ð˜ÑÑ‚Ð¾Ñ€Ð¸Ñ Ð·Ð°Ð³Ñ€ÑƒÐ¶ÐµÐ½Ð° ({count} Ð²ÑÐµÐ³Ð¾)",
                    deletePrompt: "Ð£Ð´Ð°Ð»Ð¸Ñ‚ÑŒ {count} Ð²Ñ‹Ð±Ñ€Ð°Ð½Ð½Ñ‹Ñ… ÑÐ¾Ð¾Ð±Ñ‰ÐµÐ½Ð¸Ð¹?\n\nÐ­Ñ‚Ð¾ ÑƒÐ´Ð°Ð»Ð¸Ñ‚ Ð¸Ñ… Ð´Ð»Ñ Ð²ÑÐµÑ… ÑƒÑ‡Ð°ÑÑ‚Ð½Ð¸ÐºÐ¾Ð². Ð”ÐµÐ¹ÑÑ‚Ð²Ð¸Ðµ Ð½ÐµÐ¾Ð±Ñ€Ð°Ñ‚Ð¸Ð¼Ð¾!"
                },
                apiSetup: "ÐŸÐ¾Ð»ÑƒÑ‡Ð¸Ñ‚ÑŒ Ð´Ð°Ð½Ð½Ñ‹Ðµ Ð½Ð°",
                instructions: {
                    title: "Ð˜Ð½ÑÑ‚Ñ€ÑƒÐºÑ†Ð¸Ñ",
                    content: `Ð”Ð»Ñ Ð²Ñ…Ð¾Ð´Ð° Ð²Ð°Ð¼ Ð½ÑƒÐ¶Ð½Ð¾ Ð¿Ð¾Ð»ÑƒÑ‡Ð¸Ñ‚ÑŒ Ð²Ð°ÑˆÐ¸ API ID Ð¸ API hash Ð¾Ñ‚ Telegram.
Ð”Ð¾Ð»Ð³Ð¾ Ð¾Ð±ÑŠÑÑÐ½ÑÑ‚ÑŒ, Ñ‡Ñ‚Ð¾ ÑÑ‚Ð¾ Ñ‚Ð°ÐºÐ¾Ðµ, Ð½Ð¾ Ð±ÐµÐ· Ð½Ð¸Ñ… Ð½Ð¸ÐºÐ°Ðº.
Ð”Ð»Ñ ÑÑ‚Ð¾Ð³Ð¾ Ð¿ÐµÑ€ÐµÐ¹Ð´Ð¸Ñ‚Ðµ Ð½Ð° https://my.telegram.org/auth?to=apps

Ð’Ð²ÐµÐ´Ð¸Ñ‚Ðµ Ð²Ð°Ñˆ Ð½Ð¾Ð¼ÐµÑ€ Ñ‚ÐµÐ»ÐµÑ„Ð¾Ð½Ð°, Telegram Ð¿Ñ€Ð¸ÑˆÐ»Ñ‘Ñ‚ Ð²Ð°Ð¼ ÐºÐ¾Ð´. ÐšÐ¾Ð´ Ð¿Ñ€Ð¸Ð´Ñ‘Ñ‚ Ð²Ð°Ð¼ Ð² Ð¿Ñ€Ð¸Ð»Ð¾Ð¶ÐµÐ½Ð¸Ð¸ Telegram Ð² Ð²Ð¸Ð´Ðµ Ð½Ð¾Ð²Ð¾Ð³Ð¾ Ñ‡Ð°Ñ‚Ð°.
Ð”Ð°Ð»ÐµÐµ Ð·Ð°Ð¿Ð¾Ð»Ð½Ð¸Ñ‚Ðµ Ð¿Ð¾Ð»Ñ:

App title: - Ð½Ð°Ð¿Ð¸ÑˆÐ¸Ñ‚Ðµ Ñ‡Ñ‚Ð¾ ÑƒÐ³Ð¾Ð´Ð½Ð¾, Ð½Ð°Ð¿Ñ€Ð¸Ð¼ÐµÑ€ TelegramCleanerWorkingVersion
Short name: - Ð½Ð°Ð¿Ð¸ÑˆÐ¸Ñ‚Ðµ Ñ‡Ñ‚Ð¾ ÑƒÐ³Ð¾Ð´Ð½Ð¾, Ð½Ð°Ð¿Ñ€Ð¸Ð¼ÐµÑ€ TelegramCleaner
ÐŸÐ¾ÑÑ‚Ð°Ð²ÑŒÑ‚Ðµ Ð³Ð°Ð»Ð¾Ñ‡ÐºÑƒ Ð½Ð° Ð¿Ð¾ÑÐ»ÐµÐ´Ð½ÐµÐ¹ ÑÑ‚Ñ€Ð¾ÐºÐµ, Other (specify in description)
ÐÐ°Ð¶Ð¼Ð¸Ñ‚Ðµ Create application

Telegram Ð²Ñ‹Ð´Ð°ÑÑ‚ Ð²Ð°Ð¼ ÐºÑƒÑ‡Ñƒ Ð½ÐµÐ¿Ð¾Ð½ÑÑ‚Ð½Ñ‹Ñ… ÑÑ‚Ñ€Ð¾Ñ‡ÐµÐº, Ð±ÑƒÐºÐ² Ð¸ Ñ†Ð¸Ñ„Ñ€.
Ð’Ð°Ð¼ Ð½ÑƒÐ¶Ð½Ð¾ Ð·Ð°Ð¿Ð¾Ð¼Ð½Ð¸Ñ‚ÑŒ Ð¸ ÑÐ¾Ñ…Ñ€Ð°Ð½Ð¸Ñ‚ÑŒ: API ID - ÑÑ‚Ð¾ Ñ†Ð¸Ñ„Ñ€Ñ‹ (Ð´Ð»Ñ ÑÐµÑ€Ð²ÐµÑ€Ð° Telegram ÑÑ‚Ð¾ ÐºÐ°Ðº Ð²Ð°Ñˆ Ð»Ð¾Ð³Ð¸Ð½)
Ð’Ð°Ð¼ Ð½ÑƒÐ¶Ð½Ð¾ Ð·Ð°Ð¿Ð¾Ð¼Ð½Ð¸Ñ‚ÑŒ Ð¸ ÑÐ¾Ñ…Ñ€Ð°Ð½Ð¸Ñ‚ÑŒ: API hash - (Ð´Ð»Ñ ÑÐµÑ€Ð²ÐµÑ€Ð° Telegram ÑÑ‚Ð¾ ÐºÐ°Ðº Ð²Ð°Ñˆ Ð¿Ð°Ñ€Ð¾Ð»ÑŒ)

âš ï¸ ÐŸÑ€ÐµÐ´ÑƒÐ¿Ñ€ÐµÐ¶Ð´ÐµÐ½Ð¸Ðµ: ÐÐ˜ÐšÐžÐ“Ð”Ð Ð½Ðµ Ð¿Ð¾ÐºÐ°Ð·Ñ‹Ð²Ð°Ð¹Ñ‚Ðµ Ð½Ð¸ÐºÐ¾Ð¼Ñƒ Ð²Ð°ÑˆÐ¸ API ID Ð¸ API hash, Ñ‚Ð°Ðº ÐºÐ°Ðº Ð¾Ð½Ð¸ Ð´Ð°ÑŽÑ‚ Ð¿Ñ€ÑÐ¼Ð¾Ð¹ Ð´Ð¾ÑÑ‚ÑƒÐ¿ Ðº Ð²Ð°ÑˆÐµÐ¼Ñƒ Ð°ÐºÐºÐ°ÑƒÐ½Ñ‚Ñƒ.

Ð”Ð»Ñ Ð²Ñ…Ð¾Ð´Ð° Ð² Ð¼Ð¾Ðµ Ð¿Ñ€Ð¸Ð»Ð¾Ð¶ÐµÐ½Ð¸Ðµ Ð²Ð°Ð¼ Ð¿Ð¾Ð½Ð°Ð´Ð¾Ð±ÑÑ‚ÑÑ Ð²Ð°ÑˆÐ¸ API ID Ð¸ API hash + Ð½Ð¾Ð¼ÐµÑ€ Ñ‚ÐµÐ»ÐµÑ„Ð¾Ð½Ð° + Ð¿Ð°Ñ€Ð¾Ð»ÑŒ, ÐµÑÐ»Ð¸ Ñƒ Ð²Ð°Ñ ÐµÑÑ‚ÑŒ Ð¾Ð±Ð»Ð°Ñ‡Ð½Ñ‹Ð¹ Ð¿Ð°Ñ€Ð¾Ð»ÑŒ + ÐºÐ¾Ð´, ÐºÐ¾Ñ‚Ð¾Ñ€Ñ‹Ð¹ Ð¿Ñ€Ð¸ÑˆÐ»ÐµÑ‚ Ð²Ð°Ð¼ Ð¢Ð“ (Ð½Ðµ Ð¿Ð¾ Ð¡ÐœÐ¡, Ð° Ð² Ð¿Ñ€Ð¸Ð»Ð¾Ð¶ÐµÐ½Ð¸Ð¸ Ð¢Ð“ Ð½Ð° Ñ‚ÐµÐ»ÐµÑ„Ð¾Ð½Ðµ Ð² Ð²Ð¸Ð´Ðµ Ñ‡Ð°Ñ‚Ð°). Ð¡ÐÐÐ§ÐÐ›Ð Ð’Ð’Ð•Ð”Ð˜Ð¢Ð• ÐšÐžÐ” Ð˜Ð— ÐžÐ‘Ð›ÐÐ§ÐÐžÐ“Ðž ÐŸÐÐ ÐžÐ›Ð¯, Ð”ÐžÐ–Ð”Ð˜Ð¢Ð•Ð¡Ð¬ ÐšÐžÐ”Ð ÐžÐ¢ Ð¢Ð“, Ð ÐŸÐžÐ¢ÐžÐœ Ð’Ð’Ð•Ð”Ð˜Ð¢Ð• Ð•Ð“Ðž. ÐŸÐ¾ÑÐ»Ðµ Ð¿ÐµÑ€Ð²Ð¾Ð³Ð¾ Ð²Ñ…Ð¾Ð´Ð° Ð¿Ñ€Ð¸Ð»Ð¾Ð¶ÐµÐ½Ð¸Ðµ Ð·Ð°Ð¿Ð¾Ð¼Ð½Ð¸Ñ‚ ÑÑ‚Ð¾ Ð¸ Ð²Ð°Ð¼ Ð½Ðµ Ð½ÑƒÐ¶Ð½Ð¾ Ð±ÑƒÐ´ÐµÑ‚ Ð² Ð±ÑƒÐ´ÑƒÑ‰ÐµÐ¼ Ð·Ð°Ð½Ð¾Ð²Ð¾ Ð²Ð²Ð¾Ð´Ð¸Ñ‚ÑŒ, Ð²ÑÑ‘ ÑƒÐ¶Ðµ Ð±ÑƒÐ´ÐµÑ‚ Ð·Ð°Ð¿Ð¾Ð»Ð½ÐµÐ½Ð¾, ÐµÑÐ»Ð¸ Ñ‚Ð¾Ð»ÑŒÐºÐ¾ Ð²Ñ‹ Ð½Ðµ Ð½Ð°Ð¶Ð¼Ñ‘Ñ‚Ðµ "Ð²Ñ‹Ð¹Ñ‚Ð¸ Ð¸Ð· Ð°ÐºÐºÐ°ÑƒÐ½Ñ‚Ð°", Ð½Ð°Ð¿Ñ€Ð¸Ð¼ÐµÑ€, ÐµÑÐ»Ð¸ Ð·Ð°Ñ…Ð¾Ñ‚Ð¸Ñ‚Ðµ Ð¸ÑÐ¿Ð¾Ð»ÑŒÐ·Ð¾Ð²Ð°Ñ‚ÑŒ Ð¿Ñ€Ð¸Ð»Ð¾Ð¶ÐµÐ½Ð¸Ðµ Ð´Ð»Ñ Ð´Ñ€ÑƒÐ³Ð¾Ð³Ð¾ Ð°ÐºÐºÐ°ÑƒÐ½Ñ‚Ð°.

â„¹ï¸ Ð’ÐÐ–ÐÐž: ÐŸÑ€Ð¸Ð»Ð¾Ð¶ÐµÐ½Ð¸Ðµ Ð¸ÑÐ¿Ð¾Ð»ÑŒÐ·ÑƒÐµÑ‚ Ð¸ Ñ…Ñ€Ð°Ð½Ð¸Ñ‚ Ð²ÑÐµ Ð´Ð°Ð½Ð½Ñ‹Ðµ Ñ‚Ð¾Ð»ÑŒÐºÐ¾ Ð½Ð° Ð²Ð°ÑˆÐµÐ¼ ÑƒÑÑ‚Ñ€Ð¾Ð¹ÑÑ‚Ð²Ðµ.
ÐŸÑ€Ð¾Ð³Ñ€Ð°Ð¼Ð¼Ð° ÑÐºÐ°Ñ‡Ð°ÐµÑ‚ ÑÐ¿Ð¸ÑÐ¾Ðº Ð²Ð°ÑˆÐ¸Ñ… ÑÐ¾Ð¾Ð±Ñ‰ÐµÐ½Ð¸Ð¹ Ð² Ð²Ñ‹Ð±Ñ€Ð°Ð½Ð½Ñ‹Ñ… Ñ‡Ð°Ñ‚Ð°Ñ….
Ð’Ñ‹ Ð¼Ð¾Ð¶ÐµÑ‚Ðµ Ð¿Ð¾ÑÑ‚Ð°Ð²Ð¸Ñ‚ÑŒ Ð³Ð°Ð»Ð¾Ñ‡ÐºÑƒ Ð²Ð¾Ð·Ð»Ðµ Ñ‡Ð°Ñ‚Ð° Ð¸ Ð½Ð°Ð¶Ð°Ñ‚ÑŒ "Ð£Ð´Ð°Ð»Ð¸Ñ‚ÑŒ Ð’Ð¡Ð• ÑÐ¾Ð¾Ð±Ñ‰ÐµÐ½Ð¸Ñ", Ñ‡Ñ‚Ð¾Ð±Ñ‹ ÑƒÐ´Ð°Ð»Ð¸Ñ‚ÑŒ Ð’Ð¡Ð• ÑÐ¾Ð¾Ð±Ñ‰ÐµÐ½Ð¸Ñ Ð² ÑÑ‚Ð¾Ð¼ Ñ‡Ð°Ñ‚Ðµ.
Ð˜Ð»Ð¸ Ð²Ñ‹ Ð¼Ð¾Ð¶ÐµÑ‚Ðµ Ð²Ñ‹Ð±Ñ€Ð°Ñ‚ÑŒ Ð¾Ñ‚Ð´ÐµÐ»ÑŒÐ½Ñ‹Ðµ ÑÐ¾Ð¾Ð±Ñ‰ÐµÐ½Ð¸Ñ Ð¸ Ð½Ð°Ð¶Ð°Ñ‚ÑŒ "Ð£Ð´Ð°Ð»Ð¸Ñ‚ÑŒ Ð’Ð«Ð‘Ð ÐÐÐÐ«Ð• ÑÐ¾Ð¾Ð±Ñ‰ÐµÐ½Ð¸Ñ", Ñ‡Ñ‚Ð¾Ð±Ñ‹ ÑƒÐ´Ð°Ð»Ð¸Ñ‚ÑŒ ÑÐ¾Ð¾Ð±Ñ‰ÐµÐ½Ð¸Ñ, ÐºÐ¾Ñ‚Ð¾Ñ€Ñ‹Ðµ Ð²Ñ‹ Ð²Ñ‹Ð±Ñ€Ð°Ð»Ð¸ Ð² ÑÑ‚Ð¾Ð¼ Ñ‡Ð°Ñ‚Ðµ.
Ð’ÐÐ–ÐÐž: ÐŸÑ€Ð¾Ð³Ñ€Ð°Ð¼Ð¼Ð° ÑƒÐ´Ð°Ð»ÑÐµÑ‚ ÑÐ¾Ð¾Ð±Ñ‰ÐµÐ½Ð¸Ñ Ñ‚Ð¾Ð»ÑŒÐºÐ¾ Ð² Ñ‡Ð°Ñ‚Ð°Ñ…, ÑƒÑ‡Ð°ÑÑ‚Ð½Ð¸ÐºÐ¾Ð¼ ÐºÐ¾Ñ‚Ð¾Ñ€Ñ‹Ñ… Ð²Ñ‹ ÑÐ²Ð»ÑÐµÑ‚ÐµÑÑŒ. Ð•ÑÐ»Ð¸ Ð²Ñ‹ Ð¾Ñ‚Ñ‚ÑƒÐ´Ð° Ð²Ñ‹ÑˆÐ»Ð¸, Ð¾Ð½Ð° Ð½Ðµ Ð¿Ð¾ÐºÐ°Ð¶ÐµÑ‚ ÑÑ‚Ð¾Ñ‚ Ñ‡Ð°Ñ‚ Ð² ÑÐ¿Ð¸ÑÐºÐµ, Ñ‡Ñ‚Ð¾Ð±Ñ‹ ÑÑ‚ÐµÑ€ÐµÑ‚ÑŒ ÑÐ¾Ð¾Ð±Ñ‰ÐµÐ½Ð¸Ñ, Ð½Ð°Ð´Ð¾ ÑÐ½Ð°Ñ‡Ð°Ð»Ð° Ð¿Ñ€Ð¸ÑÐ¾ÐµÐ´Ð¸Ð½Ð¸Ñ‚ÑŒÑÑ Ðº Ñ‡Ð°Ñ‚Ñƒ, Ð·Ð°Ð¿ÑƒÑÑ‚Ð¸Ñ‚ÑŒ Ð¿Ñ€Ð¾Ð³Ñ€Ð°Ð¼Ð¼Ñƒ, ÑÑ‚ÐµÑ€ÐµÑ‚ÑŒ ÑÐ¾Ð¾Ð±Ñ‰ÐµÐ½Ð¸Ñ Ð¸ Ð²Ñ‹Ð¹Ñ‚Ð¸ Ð¸Ð· Ñ‡Ð°Ñ‚Ð°.
ÐŸÑ€Ð¾Ð³Ñ€Ð°Ð¼Ð¼Ð° Ð¿Ð¾ÐºÐ°Ð·Ñ‹Ð²Ð°ÐµÑ‚ Ñ‚Ð¾Ð»ÑŒÐºÐ¾ Ñ‡Ð°Ñ‚Ñ‹/Ð³Ñ€ÑƒÐ¿Ð¿Ñ‹, Ð² Ñ‚Ð¾Ð¼ Ñ‡Ð¸ÑÐ»Ðµ Ð¸ Ð·Ð°ÐºÑ€Ñ‹Ñ‚Ñ‹Ðµ. Ð›Ð¸Ñ‡Ð½Ñ‹Ðµ Ñ‡Ð°Ñ‚Ñ‹ Ð½Ðµ Ð¿Ð¾ÐºÐ°Ð·Ñ‹Ð²Ð°ÐµÑ‚, Ð¿Ð¾Ñ‚Ð¾Ð¼Ñƒ-Ñ‡Ñ‚Ð¾ Ð¸Ñ… Ð¼Ð¾Ð¶Ð½Ð¾ Ð¸ Ñ‚Ð°Ðº ÑÑ‚ÐµÑ€ÐµÑ‚ÑŒ Ñ‡ÐµÑ€ÐµÐ· Ð¿Ñ€Ð¸Ð»Ð¾Ð¶ÐµÐ½Ð¸Ðµ Ð¢ÐµÐ»ÐµÐ³Ñ€Ð°Ð¼.`
                }
            }
        };

        const LanguageContext = createContext();

        const LanguageProvider = ({ children }) => {
            const [language, setLanguage] = useState(localStorage.getItem('tg_cleaner_lang') || 'en');

            useEffect(() => {
                localStorage.setItem('tg_cleaner_lang', language);
                // Update document title
                document.title = language === 'ru' ? "Telegram Cleaner - ÐžÑ‡Ð¸ÑÑ‚ÐºÐ°" : "Telegram Cleaner - Modern UI";
            }, [language]);

            const t = (path, params = {}) => {
                const keys = path.split('.');
                let value = translations[language];
                for (const key of keys) {
                    value = value?.[key];
                }
                if (!value) return path;

                return Object.entries(params).reduce((acc, [key, val]) => {
                    return acc.replace(`{${key}}`, val);
                }, value);
            };

            return (
                <LanguageContext.Provider value={{ language, setLanguage, t }}>
                    {children}
                </LanguageContext.Provider>
            );
        };

        const useTranslation = () => useContext(LanguageContext);

        const LanguageSelector = () => {
            const { language, setLanguage } = useTranslation();
            return (
                <div className="language-selector">
                    <button
                        className={`lang-btn ${language === 'en' ? 'active' : ''}`}
                        onClick={() => setLanguage('en')}
                    >
                        EN
                    </button>
                    <button
                        className={`lang-btn ${language === 'ru' ? 'active' : ''}`}
                        onClick={() => setLanguage('ru')}
                    >
                        RU
                    </button>
                </div>
            );
        };


        // ==================== TELEGRAM API SERVICE ====================
        // Connects to Node.js backend with real GramJS
        const API_BASE = window.location.origin;

        class TelegramService {
            constructor() {
                this.sessionId = localStorage.getItem('tg_sessionId') || null;
                this.sessionString = localStorage.getItem('tg_sessionString') || '';
                this.user = null;
            }

            async initialize(apiId, apiHash) {
                const response = await fetch(`${API_BASE}/api/init`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({
                        apiId,
                        apiHash,
                        sessionString: this.sessionString
                    })
                });
                const data = await response.json();

                if (!data.success) throw new Error(data.error);

                this.sessionId = data.sessionId;
                localStorage.setItem('tg_sessionId', data.sessionId);
                localStorage.setItem('tg_api_id', apiId);
                localStorage.setItem('tg_api_hash', apiHash);

                if (data.isAuthorized) {
                    this.user = data.user;
                }

                return { isAuthorized: data.isAuthorized, user: data.user };
            }

            async sendCode(phone) {
                const response = await fetch(`${API_BASE}/api/send-code`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ sessionId: this.sessionId, phone })
                });
                const data = await response.json();
                if (!data.success) throw new Error(data.error);
                return data;
            }

            async signIn(phone, code) {
                const response = await fetch(`${API_BASE}/api/sign-in`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ sessionId: this.sessionId, code })
                });
                const data = await response.json();

                if (data.needs2FA) {
                    return { success: false, needs2FA: true };
                }
                if (!data.success) throw new Error(data.error);

                this.sessionString = data.sessionString;
                this.user = data.user;
                localStorage.setItem('tg_sessionString', data.sessionString);

                return { success: true, user: data.user };
            }

            async signIn2FA(password) {
                const response = await fetch(`${API_BASE}/api/sign-in-2fa`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ sessionId: this.sessionId, password })
                });
                const data = await response.json();
                if (!data.success) throw new Error(data.error);

                this.sessionString = data.sessionString;
                this.user = data.user;
                localStorage.setItem('tg_sessionString', data.sessionString);

                return { success: true, user: data.user };
            }

            isAuthorized() {
                return !!this.sessionString && !!this.user;
            }

            getMe() {
                return this.user;
            }

            async getDialogs() {
                const response = await fetch(`${API_BASE}/api/dialogs?sessionId=${this.sessionId}`);
                const data = await response.json();
                if (!data.success) throw new Error(data.error);
                return data.dialogs.map(d => ({ ...d, messages: [] }));
            }

            async getMessages(chatId, offsetId = 0, limit = 8000) {
                const response = await fetch(`${API_BASE}/api/messages?sessionId=${this.sessionId}&chatId=${chatId}&limit=${limit}&offsetId=${offsetId}`);
                const data = await response.json();
                if (!data.success) throw new Error(data.error);
                return data.messages;
            }

            async deleteMessages(chatId, messageIds, revoke = true) {
                const response = await fetch(`${API_BASE}/api/delete-messages`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({
                        sessionId: this.sessionId,
                        chatId,
                        messageIds,
                        revoke
                    })
                });
                const data = await response.json();
                return data; // Returns { success: true, deleted: N } or { success: false, floodWait: S }
            }

            async batchScan(chatIds) {
                const response = await fetch(`${API_BASE}/api/batch-scan`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({
                        sessionId: this.sessionId,
                        chatIds
                    })
                });
                const data = await response.json();
                if (!data.success) throw new Error(data.error);
                return data.counts; // Returns { chatId: count }
            }

            async logout() {
                if (this.sessionId) {
                    await fetch(`${API_BASE}/api/logout`, {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify({ sessionId: this.sessionId })
                    });
                }
                this.sessionId = null;
                this.sessionString = '';
                this.user = null;
                localStorage.removeItem('tg_sessionId');
                localStorage.removeItem('tg_sessionString');
                // Keep tg_api_id and tg_api_hash so user can log back in easily
            }
        }

        const telegramService = new TelegramService();

        // ==================== LOGIN COMPONENT ====================
        function LoginScreen({ onLogin }) {
            const { t } = useTranslation();
            const [step, setStep] = useState('api'); // api, phone, code, 2fa
            const [apiId, setApiId] = useState(localStorage.getItem('tg_api_id') || '');
            const [apiHash, setApiHash] = useState(localStorage.getItem('tg_api_hash') || '');
            const [phone, setPhone] = useState('');
            const [code, setCode] = useState('');
            const [password, setPassword] = useState('');
            const [error, setError] = useState('');
            const [loading, setLoading] = useState(false);
            const [showInstructions, setShowInstructions] = useState(false);

            const handleApiSubmit = async (e) => {
                e.preventDefault();
                setError('');
                setLoading(true);
                try {
                    const result = await telegramService.initialize(parseInt(apiId), apiHash);
                    if (result.isAuthorized) {
                        onLogin(result.user);
                    } else {
                        setStep('phone');
                    }
                } catch (err) {
                    setError(err.message || 'Failed to connect. Is the server running?');
                }
                setLoading(false);
            };

            const handlePhoneSubmit = async (e) => {
                e.preventDefault();
                setError('');
                setLoading(true);
                try {
                    await telegramService.sendCode(phone);
                    setStep('code');
                } catch (err) {
                    setError(err.message || 'Failed to send code');
                }
                setLoading(false);
            };

            const handleCodeSubmit = async (e) => {
                e.preventDefault();
                setError('');
                setLoading(true);
                try {
                    const result = await telegramService.signIn(phone, code);
                    if (result.success) {
                        onLogin(result.user);
                    } else if (result.needs2FA) {
                        setStep('2fa');
                    }
                } catch (err) {
                    setError(err.message || 'Invalid code');
                }
                setLoading(false);
            };

            const handle2FASubmit = async (e) => {
                e.preventDefault();
                setError('');
                setLoading(true);
                try {
                    const result = await telegramService.signIn2FA(password);
                    if (result.success) {
                        onLogin(result.user);
                    }
                } catch (err) {
                    setError(err.message || 'Invalid password');
                }
                setLoading(false);
            };

            const Logo = () => (
                <svg className="login-logo" viewBox="0 0 100 100" fill="none">
                    <defs>
                        <linearGradient id="loginLogoGrad" x1="0%" y1="0%" x2="100%" y2="100%">
                            <stop offset="0%" stopColor="#00aaff" />
                            <stop offset="100%" stopColor="#b87fff" />
                        </linearGradient>
                    </defs>
                    <circle cx="50" cy="50" r="46" fill="url(#loginLogoGrad)" opacity="0.9" />
                    <path d="M25 50L42 44L70 28L45 52L42 68L35 55L25 50Z" fill="white" opacity="0.95" />
                    <path d="M42 44L45 52L70 28L42 44Z" fill="white" opacity="0.7" />
                </svg>
            );

            return (
                <div className="login-container">
                    <LanguageSelector />
                    <div className="login-card">
                        <Logo />
                        <h1 className="login-title">{t('loginTitle')}</h1>
                        <p className="login-subtitle">
                            {step === 'api' && t('loginSubtitle.api')}
                            {step === 'phone' && t('loginSubtitle.phone')}
                            {step === 'code' && t('loginSubtitle.code')}
                            {step === '2fa' && t('loginSubtitle.2fa')}
                        </p>

                        <div className="step-indicator">
                            <div className={`step-dot ${step === 'api' ? 'active' : 'completed'}`}></div>
                            <div className={`step-dot ${step === 'phone' ? 'active' : (step === 'code' || step === '2fa') ? 'completed' : ''}`}></div>
                            <div className={`step-dot ${step === 'code' ? 'active' : step === '2fa' ? 'completed' : ''}`}></div>
                            <div className={`step-dot ${step === '2fa' ? 'active' : ''}`}></div>
                        </div>

                        {error && <div className="login-error">{error}</div>}

                        {step === 'api' && (
                            <form onSubmit={handleApiSubmit}>
                                <div className="input-group">
                                    <label className="input-label">{t('labels.apiId')}</label>
                                    <input type="text" className="input-field" value={apiId}
                                        onChange={(e) => setApiId(e.target.value)} placeholder="12345678" required />
                                </div>
                                <div className="input-group">
                                    <label className="input-label">{t('labels.apiHash')}</label>
                                    <input type="text" className="input-field" value={apiHash}
                                        onChange={(e) => setApiHash(e.target.value)} placeholder="0123456789abcdef..." required />
                                </div>
                                <button type="submit" className="btn btn-primary login-btn" disabled={loading}>
                                    {loading ? <span className="loading-spinner"></span> : t('buttons.continue')}
                                </button>
                                <div className="api-setup">
                                    <p className="api-setup-title">
                                        {t('apiSetup')} <a href="https://my.telegram.org" target="_blank" className="api-link">my.telegram.org</a>
                                        <a className="instructions-link" onClick={() => setShowInstructions(true)}>
                                            ({t('instructions.title')})
                                        </a>
                                    </p>
                                </div>
                            </form>
                        )}

                        {step === 'phone' && (
                            <form onSubmit={handlePhoneSubmit}>
                                <div className="input-group">
                                    <label className="input-label">{t('labels.phone')}</label>
                                    <input type="tel" className="input-field" value={phone}
                                        onChange={(e) => setPhone(e.target.value)} placeholder="+1234567890" required />
                                </div>
                                <button type="submit" className="btn btn-primary login-btn" disabled={loading}>
                                    {loading ? <span className="loading-spinner"></span> : t('buttons.sendCode')}
                                </button>
                            </form>
                        )}

                        {step === 'code' && (
                            <form onSubmit={handleCodeSubmit}>
                                <div className="login-info">Code sent to {phone}</div>
                                <div className="input-group">
                                    <label className="input-label">{t('labels.code')}</label>
                                    <input type="text" className="input-field" value={code}
                                        onChange={(e) => setCode(e.target.value)} placeholder="12345" required autoFocus />
                                </div>
                                <button type="submit" className="btn btn-primary login-btn" disabled={loading}>
                                    {loading ? <span className="loading-spinner"></span> : t('buttons.verify')}
                                </button>
                            </form>
                        )}

                        {step === '2fa' && (
                            <form onSubmit={handle2FASubmit}>
                                <div className="login-info">Two-factor authentication required</div>
                                <div className="input-group">
                                    <label className="input-label">{t('labels.password')}</label>
                                    <input type="password" className="input-field" value={password}
                                        onChange={(e) => setPassword(e.target.value)} placeholder={t('labels.password')} required autoFocus />
                                </div>
                                <button type="submit" className="btn btn-primary login-btn" disabled={loading}>
                                    {loading ? <span className="loading-spinner"></span> : t('buttons.submit')}
                                </button>
                            </form>
                        )}
                    </div>

                    {showInstructions && (
                        <div className="instructions-modal" onClick={() => setShowInstructions(false)}>
                            <div className="instructions-content" onClick={(e) => e.stopPropagation()}>
                                <h2>
                                    {t('instructions.title')}
                                    <button className="instructions-close" onClick={() => setShowInstructions(false)}>
                                        Ã—
                                    </button>
                                </h2>
                                <div className="instructions-text">
                                    {t('instructions.content')}
                                </div>
                            </div>
                        </div>
                    )}
                </div>
            );
        }

        // ==================== MAIN APP COMPONENT ====================
        function App() {
            const { t } = useTranslation();
            const [isLoggedIn, setIsLoggedIn] = useState(false);
            const [user, setUser] = useState(null);
            const [chats, setChats] = useState([]);
            const [expandedChat, setExpandedChat] = useState(null);
            const [selectedChats, setSelectedChats] = useState(new Set());
            const [selectedMessages, setSelectedMessages] = useState(new Set());
            const [isRefreshing, setIsRefreshing] = useState(false);
            const [lastRefresh, setLastRefresh] = useState(null);
            const [isDeleting, setIsDeleting] = useState(false);
            const [deleteProgress, setDeleteProgress] = useState({ current: 0, total: 0 });
            const [loadingMessages, setLoadingMessages] = useState(null);
            const [isLoadingMore, setIsLoadingMore] = useState(false); // New state for recursive loading
            const [stopLoading, setStopLoading] = useState(false); // Flag to abort loading
            const [downloadProgress, setDownloadProgress] = useState({ current: 0, total: 0, chatName: '' });
            const [initializing, setInitializing] = useState(true);
            const [isScanning, setIsScanning] = useState(false);
            const [scanProgress, setScanProgress] = useState({ current: 0, total: 0 });
            const [hideEmpty, setHideEmpty] = useState(true); // Default to TRUE as requested

            useEffect(() => {
                const checkAuth = async () => {
                    const apiId = localStorage.getItem('tg_api_id');
                    const apiHash = localStorage.getItem('tg_api_hash');
                    const sessionString = localStorage.getItem('tg_sessionString');

                    if (apiId && apiHash && sessionString) {
                        try {
                            const result = await telegramService.initialize(parseInt(apiId), apiHash);
                            if (result.isAuthorized) {
                                setUser(result.user);
                                setIsLoggedIn(true);
                                await loadChats();
                            }
                        } catch (err) {
                            console.error('Auto-login failed:', err);
                        }
                    }
                    setInitializing(false);
                };
                checkAuth();
            }, []);

            const loadChats = async () => {
                setIsRefreshing(true);
                // Capture current expanded chat ID before we potentially wipe state or if we need it
                // Actually 'expandedChat' from closure is fine as long as we don't depend on updated state immediately.
                const currentExpandedChatId = expandedChat;

                try {
                    const dialogs = await telegramService.getDialogs();
                    // Ensure messages array is initialized
                    // NOTE: If we want to preserve messages for the Expanded Chat, we could check if ID matches and keep them?
                    // BUT: User clicked Refresh, so they probably WANT to refresh the messages too.
                    // SO: We should wipe them (default behavior) but then immediately trigger a reload for that chat.

                    const hydratedDialogs = dialogs.map(d => ({ ...d, messages: d.messages || [] }));
                    setChats(hydratedDialogs);
                    setLastRefresh(new Date());

                    // Auto-start scan
                    startBackgroundScan(hydratedDialogs);

                    // If a chat was expanded, reload its messages
                    if (currentExpandedChatId) {
                        // Small delay to ensure state and simple rate limit
                        setTimeout(() => {
                            loadMessages(currentExpandedChatId, 0, false, true);
                        }, 500);
                    }

                } catch (err) {
                    console.error('Failed to load chats:', err);
                }
                setIsRefreshing(false);
            };

            // Modified to recursively load ALL messages
            const loadMessages = async (chatId, offsetId = 0, append = false, autoContinue = false) => {
                const chat = chats.find(c => c.id === chatId);
                if (!chat) return;

                // If we are starting a fresh load for a chat that already has messages, and not appending,
                // we might want to clear them or just sync. For now, let's assume we want to load history.

                if (!append) {
                    setLoadingMessages(chatId);
                    setStopLoading(false);
                    setDownloadProgress({ current: 0, total: chat.myMessageCount || chat.messageCount || 0, chatName: chat.name || 'Unknown Chat' });
                } else {
                    setIsLoadingMore(true);
                }

                try {
                    // Fetch batch
                    const messages = await telegramService.getMessages(chatId, offsetId);

                    if (messages.length === 0) {
                        setLoadingMessages(null);
                        setIsLoadingMore(false);
                        setDownloadProgress({ current: 0, total: 0, chatName: '' });
                        return; // End of history
                    }

                    // Update state
                    setChats(prev => prev.map(c => {
                        if (c.id !== chatId) return c;

                        let updatedMessages = [];
                        if (append) {
                            const existingIds = new Set(c.messages.map(m => m.id));
                            const newUnique = messages.filter(m => !existingIds.has(m.id));
                            updatedMessages = [...c.messages, ...newUnique];
                        } else {
                            updatedMessages = messages;
                        }

                        return {
                            ...c,
                            messages: updatedMessages,
                            messageCount: Math.max(c.messageCount, updatedMessages.length)
                        };
                    }));

                    // Update download progress
                    setDownloadProgress(prev => ({
                        ...prev,
                        current: append ? prev.current + messages.length : messages.length,
                        total: Math.max(prev.total, (append ? prev.current + messages.length : messages.length))
                    }));

                    // Recursive loop logic
                    if ((autoContinue || !append) && messages.length > 0) {
                        // Check if we should stop
                        // We can't easily read the CURRENT value of stopLoading from state here due to closure
                        // But we can check a ref if we had one. 
                        // Instead, we'll chain the next call loosely or use a slightly different pattern.
                        // For simplicity in this functional component without refs:
                        // We will rely on the user UI "Stop" to toggle a ref or just let it run for now.
                        // To properly stop, we need a Ref. Let's add a Ref hook in the next step if strictly needed.
                        // For now, let's just wait 30s and load next batch.

                        await new Promise(r => setTimeout(r, 30000)); // 30 second delay between batches
                        const lastMsg = messages[messages.length - 1];

                        // We need to check if user switched chats or wanted to stop.
                        // A simple way is to pass a "runId" or check if `loadingMessages` is still this chat.
                        // Since we can't see the fresh state, this is tricky in a simple recursive function.
                        // BETTER: Use a useEffect or a separate specific "RecursiveLoader" function that checks a ref.

                        // Let's call ourselves again with new offset
                        // We pass 'true' for append and 'true' for autoContinue

                        // NOTE: To fix the "Stop" issue, we'll assume for now the user wants ALL unless they reload page.
                        // We check if the chat is still the active one (expandedChat).
                        // We can't access `expandedChat` state inside this closure easily if it's stale.
                        // We will proceed with the recursive load for THIS chat specifically.

                        loadMessages(chatId, lastMsg.id, true, true);
                    } else {
                        setLoadingMessages(null);
                        setIsLoadingMore(false);
                        setDownloadProgress({ current: 0, total: 0, chatName: '' });
                    }

                } catch (err) {
                    console.error('Failed to load messages:', err);
                    setLoadingMessages(null);
                    setIsLoadingMore(false);
                    setDownloadProgress({ current: 0, total: 0, chatName: '' });
                }
            };

            const handleLogin = async (userData) => {
                setUser(userData);
                setIsLoggedIn(true);
                await loadChats();
            };

            const handleLogout = async () => {
                await telegramService.logout();
                setIsLoggedIn(false);
                setUser(null);
                setChats([]);
            };

            const toggleChatExpansion = async (chatId) => {
                if (expandedChat === chatId) {
                    setExpandedChat(null);
                    setLoadingMessages(null); // Cancel loading indicator logic roughly
                } else {
                    setExpandedChat(chatId);
                    // Start loading ALL messages (autoContinue = true)
                    await loadMessages(chatId, 0, false, true);
                }
            };

            const toggleChatSelection = (chatId) => {
                const newSelectedChats = new Set(selectedChats);
                const newSelectedMessages = new Set(selectedMessages);
                const chat = chats.find(c => c.id === chatId);

                if (newSelectedChats.has(chatId)) {
                    newSelectedChats.delete(chatId);
                    if (chat) {
                        chat.messages.forEach(msg => newSelectedMessages.delete(msg.id));
                    }
                } else {
                    newSelectedChats.add(chatId);
                    // FORCE CLEAR individual messages for this chat to prevent double counting
                    if (chat) {
                        chat.messages.forEach(msg => newSelectedMessages.delete(msg.id));
                    }
                }

                setSelectedChats(newSelectedChats);
                setSelectedMessages(newSelectedMessages);
            };

            const toggleMessageSelection = (messageId, chatId) => {
                const newSelectedLogs = new Set(selectedMessages);
                const newSelectedChats = new Set(selectedChats);

                // If the CHAT is selected, we are breaking the "All" selection
                // down to individual messages (minus the one clicked)
                if (chatId && selectedChats.has(chatId)) {
                    newSelectedChats.delete(chatId);

                    // Add ALL current messages from this chat
                    const chat = chats.find(c => c.id === chatId);
                    if (chat) {
                        chat.messages.forEach(m => {
                            if (m.id !== messageId) {
                                newSelectedLogs.add(m.id);
                            }
                        });
                    }
                    // We don't need to check "if (newSelected...)" because we are transitioning from "All" to "All-1"
                } else {
                    // Normal toggle behavior
                    if (newSelectedLogs.has(messageId)) {
                        newSelectedLogs.delete(messageId);
                    } else {
                        newSelectedLogs.add(messageId);
                    }
                }

                setSelectedMessages(newSelectedLogs);
                setSelectedChats(newSelectedChats);
            };

            const selectAllMessagesInChat = (chatId) => {
                const chat = chats.find(c => c.id === chatId);
                if (chat) {
                    const newSelected = new Set(selectedMessages);
                    chat.messages.forEach(msg => newSelected.add(msg.id));
                    setSelectedMessages(newSelected);
                }
            };

            const deselectAllMessagesInChat = (chatId) => {
                const chat = chats.find(c => c.id === chatId);
                if (chat) {
                    const newSelectedMessages = new Set(selectedMessages);
                    const newSelectedChats = new Set(selectedChats);

                    // If whole chat was selected, remove it too; otherwise UI stays checked
                    newSelectedChats.delete(chatId);

                    chat.messages.forEach(msg => newSelectedMessages.delete(msg.id));

                    setSelectedMessages(newSelectedMessages);
                    setSelectedChats(newSelectedChats);
                }
            };

            const selectAll = () => {
                setSelectedChats(new Set(chats.map(c => c.id)));
                // Clear all individual messages to rely on chat-based counting
                setSelectedMessages(new Set());
            };

            const deselectAll = () => {
                setSelectedChats(new Set());
                setSelectedMessages(new Set());
            };

            const refreshMessages = async () => {
                await loadChats();
            };

            const handleDelete = async () => {
                const manualSelectionCount = selectedMessages.size;
                let chatSelectionCount = 0;
                chats.forEach(c => {
                    if (selectedChats.has(c.id)) chatSelectionCount += (c.myMessageCount || 0);
                });

                const totalToDelete = manualSelectionCount + chatSelectionCount;

                if (totalToDelete === 0) return;

                if (!confirm(t('chat.deletePrompt', { count: totalToDelete }))) {
                    return;
                }

                setIsDeleting(true);
                setDeleteProgress({ current: 0, total: totalToDelete });

                const delay = (ms) => new Promise(resolve => setTimeout(resolve, ms));
                const randomDelay = () => {
                    const min = 25000; // 25 seconds
                    const max = 30000; // 30 seconds
                    const randomMs = Math.floor(Math.random() * (max - min + 1)) + min;
                    return delay(randomMs);
                };

                try {
                    let totalDeletedActual = 0;

                    // 1. Process Explicit Selected Messages
                    const messagesByChat = {};
                    for (const chat of chats) {
                        // If whole chat selected, we skip manual messages from it (handled in step 2)
                        // Although toggle logic clears them, let's be safe.
                        if (selectedChats.has(chat.id)) continue;

                        const chatMsgIds = chat.messages
                            .filter(msg => selectedMessages.has(msg.id))
                            .map(msg => msg.id);
                        if (chatMsgIds.length > 0) {
                            messagesByChat[chat.id] = chatMsgIds;
                        }
                    }

                    // Process manual messages
                    for (const chatId of Object.keys(messagesByChat)) {
                        const ids = messagesByChat[chatId];
                        const CHUNK_SIZE = 300;
                        for (let i = 0; i < ids.length; i += CHUNK_SIZE) {
                            const chunk = ids.slice(i, i + CHUNK_SIZE);
                            const result = await telegramService.deleteMessages(chatId, chunk, true);

                            if (result.success) {
                                totalDeletedActual += chunk.length;
                                setDeleteProgress(prev => ({ ...prev, current: totalDeletedActual }));
                                setChats(prev => prev.map(c =>
                                    c.id === chatId
                                        ? {
                                            ...c,
                                            messages: c.messages.filter(m => !chunk.includes(m.id)),
                                            myMessageCount: Math.max(0, (c.myMessageCount || 0) - chunk.length)
                                        }
                                        : c
                                ));
                                // Random delay between 25-30 seconds between batches
                                if (i + CHUNK_SIZE < ids.length) {
                                    await randomDelay();
                                }
                            } else if (result.floodWait) {
                                // Hard stop if FLOOD_WAIT > 120 seconds
                                if (result.floodWait > 120) {
                                    alert(t('status.floodWaitLong', { seconds: result.floodWait }));
                                    throw new Error(`FLOOD_WAIT: ${result.floodWait}s - Aborting deletion`);
                                } else {
                                    // Never retry immediately - abort this batch
                                    alert(t('status.floodWaitShort', { seconds: result.floodWait }));
                                    throw new Error(`FLOOD_WAIT: ${result.floodWait}s - Aborting deletion`);
                                }
                            } else {
                                // Other error - abort
                                throw new Error('Deletion failed');
                            }
                        }
                    }

                    // 2. Process Whole Chat Selections
                    for (const chatId of selectedChats) {
                        const chat = chats.find(c => c.id === chatId);
                        if (!chat) continue;

                        let hasMore = true;
                        // Loop until empty
                        while (hasMore) {
                            // Fetch batch
                            try {
                                const messages = await telegramService.getMessages(chatId, 0, 300);
                                if (messages.length === 0) {
                                    hasMore = false;
                                    break;
                                }

                                const ids = messages.map(m => m.id);
                                const result = await telegramService.deleteMessages(chatId, ids, true);

                                if (result.success) {
                                    totalDeletedActual += ids.length;
                                    setDeleteProgress(prev => ({ ...prev, current: totalDeletedActual }));

                                    // Update UI
                                    setChats(prev => prev.map(c =>
                                        c.id === chatId
                                            ? {
                                                ...c,
                                                messages: [],
                                                hasMyMessages: false,
                                                myMessageCount: Math.max(0, (c.myMessageCount || 0) - ids.length)
                                            }
                                            : c
                                    ));

                                    // Random delay between 25-30 seconds between batches
                                    await randomDelay();
                                } else if (result.floodWait) {
                                    // Hard stop if FLOOD_WAIT > 120 seconds
                                    if (result.floodWait > 120) {
                                        alert(t('status.floodWaitLong', { seconds: result.floodWait }));
                                        throw new Error(`FLOOD_WAIT: ${result.floodWait}s - Aborting deletion`);
                                    } else {
                                        // Never retry immediately - abort
                                        alert(t('status.floodWaitShort', { seconds: result.floodWait }));
                                        throw new Error(`FLOOD_WAIT: ${result.floodWait}s - Aborting deletion`);
                                    }
                                } else {
                                    // Other error - abort this chat
                                    hasMore = false;
                                }
                            } catch (e) {
                                console.error("Error processing chat delete", chatId, e);
                                hasMore = false;
                                // Re-throw FLOOD_WAIT errors to stop entire deletion process
                                if (e.message && e.message.includes('FLOOD_WAIT')) {
                                    throw e;
                                }
                            }
                        }
                    }

                    // Clear selections
                    setSelectedMessages(new Set());
                    setSelectedChats(new Set());
                    alert(`Successfully deleted ${totalDeletedActual} message(s)!`);
                } catch (err) {
                    console.error('Delete failed:', err);
                    alert('Failed to delete: ' + err.message);
                }

                setIsDeleting(false);
            };

            // Refactored Scan to take chats argument for auto-start
            const startBackgroundScan = async (chatsToScan) => {
                if (isScanning) return; // Prevent double scan
                setIsScanning(true);
                setScanProgress({ current: 0, total: chatsToScan.length });

                try {
                    // Extract IDs
                    const idsToScan = chatsToScan.map(c => c.id);

                    // Call Batch API
                    // If list is huge (e.g. 5000), we might want to frontend-chunk it too, 
                    // but server handles batching mostly. Let's send in chunks of 100 to update UI progress.

                    const CHUNK_SIZE = 50;
                    const activeIdsSet = new Set();

                    for (let i = 0; i < idsToScan.length; i += CHUNK_SIZE) {
                        const chunk = idsToScan.slice(i, i + CHUNK_SIZE);

                        try {
                            const countsChunk = await telegramService.batchScan(chunk);
                            // countsChunk is object { id: count }
                            const idsWithCounts = Object.keys(countsChunk);

                            // Update UI progressively
                            setChats(prev => prev.map(c => {
                                if (chunk.includes(c.id)) {
                                    const count = countsChunk[c.id] || 0;
                                    const isActive = count > 0;
                                    return {
                                        ...c,
                                        hasScanned: true,
                                        hasMyMessages: isActive,
                                        myMessageCount: count, // Store the count
                                        messages: c.messages.length > 0 ? c.messages : []
                                    };
                                }
                                return c;
                            }));
                        } catch (e) {
                            console.error('Batch scan chunk failed', e);
                        }

                        setScanProgress(prev => ({ ...prev, current: Math.min(i + CHUNK_SIZE, idsToScan.length) }));
                    }

                } catch (err) {
                    console.error('Scan failed', err);
                }

                // Final cleanup status
                setIsScanning(false);
            };

            const handleScan = () => startBackgroundScan(chats);

            const filteredChats = chats.filter(chat => {
                // Hide Empty (Strict)
                // If hideEmpty is ON, we ONLY show if hasMyMessages === true.
                // If checking hasn't finished (undefined), we HIDE it (strict mode).
                // User will see items "pop in" as they are verified.

                const matchesEmptyFilter = !hideEmpty || (chat.hasMyMessages === true);

                return matchesEmptyFilter;
            });

            const totalSelectedMessages = selectedMessages.size + chats.reduce((acc, chat) =>
                selectedChats.has(chat.id) ? acc + (chat.myMessageCount || 0) : acc, 0
            );
            const totalChats = chats.length;

            // Show loading screen during initialization
            if (initializing) {
                return (
                    <div className="login-container">
                        <LanguageSelector />
                        <div className="login-card" style={{ textAlign: 'center' }}>
                            <div className="loading-spinner" style={{ width: 40, height: 40, margin: '0 auto 20px' }}></div>
                            <p className="login-subtitle">{t('status.loading')}</p>
                        </div>
                    </div>
                );
            }

            // Show login if not authenticated
            if (!isLoggedIn) {
                return <LoginScreen onLogin={handleLogin} />;
            }

            return (
                <div className="container">
                    <LanguageSelector />
                    <div className="header">
                        <div className="logo-container">
                            <svg className="logo" viewBox="0 0 100 100" fill="none" xmlns="http://www.w3.org/2000/svg">
                                {/* Background circle with gradient */}
                                <defs>
                                    <linearGradient id="logoGrad" x1="0%" y1="0%" x2="100%" y2="100%">
                                        <stop offset="0%" stopColor="#00aaff" />
                                        <stop offset="100%" stopColor="#b87fff" />
                                    </linearGradient>
                                    <linearGradient id="sparkleGrad" x1="0%" y1="0%" x2="100%" y2="100%">
                                        <stop offset="0%" stopColor="#ffffff" />
                                        <stop offset="100%" stopColor="#66ccff" />
                                    </linearGradient>
                                </defs>
                                {/* Main circle */}
                                <circle cx="50" cy="50" r="46" fill="url(#logoGrad)" opacity="0.9" />
                                {/* Paper plane / telegram style */}
                                <path d="M25 50L42 44L70 28L45 52L42 68L35 55L25 50Z" fill="white" opacity="0.95" />
                                <path d="M42 44L45 52L70 28L42 44Z" fill="white" opacity="0.7" />
                                <path d="M42 68L45 52L55 58L42 68Z" fill="white" opacity="0.6" />
                                {/* Broom / cleaning element */}
                                <rect x="60" y="55" width="4" height="22" rx="2" fill="white" transform="rotate(-30 62 66)" />
                                <ellipse cx="75" cy="78" rx="10" ry="6" fill="white" opacity="0.9" transform="rotate(-30 75 78)" />
                                {/* Sparkles */}
                                <circle cx="20" cy="25" r="3" fill="url(#sparkleGrad)" />
                                <circle cx="82" cy="18" r="2.5" fill="url(#sparkleGrad)" />
                                <circle cx="15" cy="70" r="2" fill="url(#sparkleGrad)" />
                                {/* Star sparkle */}
                                <path d="M85 40L87 44L91 44L88 47L89 51L85 48L81 51L82 47L79 44L83 44Z" fill="white" />
                            </svg>
                            <span className="logo-text">{t('appTitle')}</span>
                        </div>
                        <p>{t('subtitle')}</p>
                    </div>

                    <div className="glass-card">
                        <div style={{ display: 'flex', justifyContent: 'space-between', alignItems: 'center', marginBottom: 24 }}>
                            <div className="status-badge" style={{ marginBottom: 0 }}>
                                <span className="status-dot"></span>
                                {t('status.connectedAs')} {user?.phone || user?.username || 'User'}
                            </div>
                            <button className="logout-btn" onClick={handleLogout}>
                                {t('buttons.logout')}
                            </button>
                        </div>

                        <div className="stats-grid">
                            <div className="stat-card">
                                <div className="stat-number">{totalChats}</div>
                                <div className="stat-label">{t('stats.totalChats')}</div>
                            </div>
                            <div className="stat-card">
                                <div className="stat-number">{selectedChats.size}</div>
                                <div className="stat-label">{t('stats.chatsSelected')}</div>
                            </div>
                            <div className="stat-card">
                                <div className="stat-number">{totalSelectedMessages}</div>
                                <div className="stat-label">{t('stats.messagesSelected')}</div>
                            </div>
                        </div>

                        {totalSelectedMessages > 0 && (
                            <div className="selection-banner">
                                <div className="selection-info">
                                    <span>ðŸŽ¯</span>
                                    <span>{t('status.readyToDelete', { count: totalSelectedMessages, s: totalSelectedMessages !== 1 ? 's' : '' })}</span>
                                </div>
                            </div>
                        )}

                        <div className="action-buttons" role="group" aria-label="Chat selection actions">
                            <button className="btn btn-primary" onClick={selectAll} aria-label="Select all chats">
                                {t('buttons.selectAll')}
                            </button>
                            <button className="btn btn-secondary" onClick={deselectAll} aria-label="Deselect all chats">
                                {t('buttons.deselectAll')}
                            </button>
                            <button
                                className={`btn btn-refresh ${isRefreshing ? 'refreshing' : ''}`}
                                onClick={refreshMessages}
                                disabled={isRefreshing}
                                aria-label="Refresh messages list"
                            >
                                <span className="refresh-icon">ðŸ”„</span>
                                {isRefreshing ? t('buttons.refreshing') : t('buttons.refresh')}
                            </button>
                        </div>

                        <div className="refresh-info">
                            <span>ðŸ“‹ {t('status.messagesLoaded', { count: chats.reduce((sum, c) => sum + c.messages.length, 0), chats: chats.length })}</span>
                            <span>ðŸ• {lastRefresh ? t('status.lastRefresh', { time: lastRefresh.toLocaleTimeString() }) : t('status.notRefreshed')}</span>
                        </div>

                        {loadingMessages && downloadProgress.total > 0 && (
                            <div className="deletion-progress">
                                <div style={{ fontWeight: 600, marginBottom: 8 }}>{t('status.downloadingMessages', { chatName: downloadProgress.chatName })}</div>
                                <div className="progress-bar-container">
                                    <div
                                        className="progress-bar"
                                        style={{ width: `${downloadProgress.total > 0 ? (downloadProgress.current / downloadProgress.total) * 100 : 0}%` }}
                                    ></div>
                                </div>
                                <div className="progress-stats">
                                    <span>{t('status.downloadProgress', { current: downloadProgress.current, total: downloadProgress.total })}</span>
                                    <span>{downloadProgress.total > 0 ? Math.round((downloadProgress.current / downloadProgress.total) * 100) : 0}%</span>
                                </div>
                            </div>
                        )}

                        {isDeleting && (
                            <div className="deletion-progress">
                                <div style={{ fontWeight: 600, marginBottom: 8 }}>{t('status.deletingMessages')}</div>
                                <div className="progress-bar-container">
                                    <div
                                        className="progress-bar"
                                        style={{ width: `${deleteProgress.total > 0 ? (deleteProgress.current / deleteProgress.total) * 100 : 0}%` }}
                                    ></div>
                                </div>
                                <div className="progress-stats">
                                    <span>{t('status.deletedProgress', { current: deleteProgress.current, total: deleteProgress.total })}</span>
                                    <span>{deleteProgress.total > 0 ? Math.round((deleteProgress.current / deleteProgress.total) * 100) : 0}%</span>
                                </div>
                            </div>
                        )}


                        <div className="chat-list">
                            {filteredChats.map(chat => (
                                <div key={chat.id} className="chat-item">
                                    <div className={`chat-header ${expandedChat === chat.id ? 'expanded' : ''}`}>
                                        <div className="checkbox-wrapper">
                                            <input
                                                type="checkbox"
                                                className="checkbox"
                                                checked={selectedChats.has(chat.id)}
                                                onChange={(e) => {
                                                    e.stopPropagation();
                                                    toggleChatSelection(chat.id);
                                                }}
                                                aria-label={`Select chat ${chat.name}`}
                                            />
                                        </div>
                                        <div className="avatar" aria-hidden="true">{chat.avatar}</div>
                                        <div
                                            className="chat-info"
                                            onClick={() => toggleChatExpansion(chat.id)}
                                            role="button"
                                            tabIndex={0}
                                            onKeyDown={(e) => e.key === 'Enter' && toggleChatExpansion(chat.id)}
                                            aria-expanded={expandedChat === chat.id}
                                            aria-label={`${chat.name}, ${chat.messageCount} messages. Click to ${expandedChat === chat.id ? 'collapse' : 'expand'}`}
                                        >
                                            <div className="chat-name">
                                                {chat.name}
                                                <span className="badge" aria-label={chat.type === 'group' ? t('chat.group') : t('chat.private')}>
                                                    {chat.type === 'group' ? 'ðŸ‘¥' : 'ðŸ’¬'}
                                                </span>
                                            </div>
                                            <div className="chat-preview">{chat.lastMessage}</div>
                                        </div>
                                        <div className="chat-meta">
                                            <div className="message-count" title="My messages in chat" style={{ width: 'auto', padding: '0 8px', borderRadius: '12px' }}>
                                                {t('chat.my')} {chat.myMessageCount !== undefined ? chat.myMessageCount : '...'}
                                            </div>
                                            <div className="chat-time">{chat.time}</div>
                                            <span className={`expand-icon ${expandedChat === chat.id ? 'expanded' : ''}`}>
                                                â–¼
                                            </span>
                                        </div>
                                    </div>

                                    {expandedChat === chat.id && (
                                        <div className="messages-container">
                                            {loadingMessages === chat.id && chat.messages.length === 0 ? (
                                                <div style={{ textAlign: 'center', padding: 40 }}>
                                                    <div className="loading-spinner" style={{ width: 32, height: 32, margin: '0 auto 16px' }}></div>
                                                    <p style={{ color: 'var(--text-muted)' }}>{t('status.loading')}</p>
                                                </div>
                                            ) : chat.messages.length === 0 ? (
                                                <div style={{ textAlign: 'center', padding: 40, color: 'var(--text-muted)' }}>
                                                    <p>{t('chat.noMessages')}</p>
                                                </div>
                                            ) : (
                                                <>
                                                    <div className="message-controls" role="group" aria-label="Message selection actions">
                                                        <button
                                                            className="btn btn-primary"
                                                            onClick={() => selectAllMessagesInChat(chat.id)}
                                                            aria-label={`Select all ${chat.messages.length} messages in ${chat.name}`}
                                                        >
                                                            {t('chat.selectAllMessages', { count: chat.messages.length })}
                                                        </button>
                                                        <button
                                                            className="btn btn-secondary"
                                                            onClick={() => deselectAllMessagesInChat(chat.id)}
                                                            aria-label={`Deselect all messages in ${chat.name}`}
                                                        >
                                                            {t('chat.deselectAllMessages')}
                                                        </button>
                                                    </div>

                                                    <div className="messages-list">
                                                        {chat.messages.map(message => (
                                                                <div
                                                                    key={message.id}
                                                                    className={`message-item ${selectedMessages.has(message.id) || selectedChats.has(chat.id) ? 'selected' : ''}`}
                                                                    onClick={() => toggleMessageSelection(message.id, chat.id)}
                                                                >
                                                                    <div className="checkbox-wrapper">
                                                                        <input
                                                                            type="checkbox"
                                                                            className="checkbox message-checkbox"
                                                                            checked={selectedMessages.has(message.id) || selectedChats.has(chat.id)}
                                                                            readOnly
                                                                            aria-label={`Select message: ${(message.text || '').substring(0, 50)}`}
                                                                        />
                                                                    </div>
                                                                    <div className="message-content">
                                                                        <div className="message-text">
                                                                            {message.type !== 'text' && (
                                                                                <span className={`message-type ${message.type}`}>
                                                                                    {message.type === 'photo' && t('chat.photo')}
                                                                                    {message.type === 'video' && t('chat.video')}
                                                                                    {message.type === 'file' && t('chat.file')}
                                                                                </span>
                                                                            )}
                                                                            {message.text}
                                                                        </div>
                                                                        <div className="message-meta">
                                                                            <span className="message-sender">{message.sender}</span>
                                                                            <span>â€¢</span>
                                                                            <span>{message.date}</span>
                                                                        </div>
                                                                    </div>
                                                                </div>
                                                            ))}
                                                    </div>

                                                    {/* Sync Status / Stop Button */}
                                                    {(loadingMessages === chat.id || isLoadingMore) && (
                                                        <div style={{ textAlign: 'center', marginTop: 16, padding: 12, background: 'rgba(0,0,0,0.2)', borderRadius: 8 }}>
                                                            <div className="loading-spinner" style={{ width: 16, height: 16, borderTopColor: 'var(--primary)', borderRightColor: 'var(--primary)', marginRight: 8, verticalAlign: 'middle' }}></div>
                                                            <span style={{ fontSize: '13px', color: 'var(--text-secondary)' }}>
                                                                {t('chat.syncing', { count: chat.messages.length })}
                                                            </span>
                                                            {/*
                                                            <button
                                                                className="btn btn-secondary"
                                                                style={{ marginLeft: 12, padding: '4px 12px', fontSize: '12px' }}
                                                                onClick={() => window.location.reload()} // Crude stop
                                                            >
                                                                Stop
                                                            </button>
                                                            */}
                                                        </div>
                                                    )}

                                                    {/* End of history indicator */}
                                                    {!(loadingMessages === chat.id || isLoadingMore) && chat.messages.length > 0 && (
                                                        <div style={{ textAlign: 'center', marginTop: 16, color: 'var(--text-muted)', fontSize: '12px' }}>
                                                            {t('chat.endOfHistory', { count: chat.messages.length })}
                                                        </div>
                                                    )}
                                                </>
                                            )}
                                        </div>
                                    )}
                                </div>
                            ))}
                        </div>

                        <button
                            className="btn btn-danger"
                            disabled={totalSelectedMessages === 0 || isDeleting}
                            onClick={handleDelete}
                            aria-label={`Delete ${totalSelectedMessages} selected message${totalSelectedMessages !== 1 ? 's' : ''}`}
                        >
                            {isDeleting ? (
                                <><span className="loading-spinner"></span> {t('buttons.deleting')}</>
                            ) : (
                                <>{t('buttons.delete', { count: totalSelectedMessages, s: totalSelectedMessages !== 1 ? 's' : '' })}</>
                            )}
                        </button>
                    </div>
                </div >
            );
        }

        const root = ReactDOM.createRoot(document.getElementById('root'));
        root.render(
            <LanguageProvider>
                <App />
            </LanguageProvider>
        );
    </script>
</body>

</html>